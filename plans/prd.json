{
  "project": "StoicTrader",
  "source": {
    "implementation_plan_path": "IMPLEMENTATION_PLAN.md",
    "contract_path": "specs/CONTRACT.md"
  },
  "rules": {
    "one_story_per_iteration": true,
    "one_commit_per_story": true,
    "no_prd_rewrite": true,
    "passes_only_flips_after_verify_green": true
  },
  "items": [
    {
      "id": "S0-000",
      "priority": 200,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-A Launch Policy Baseline",
      "category": "policy",
      "description": "Create launch policy doc with explicit constraints (instruments, position limits, order rate, environments).",
      "contract_refs": [
        "P0-A Launch Policy Baseline"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/launch_policy.md",
          "evidence/phase0/policy/launch_policy_snapshot.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes allowed instruments/venues.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes max position/daily loss.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes max order rate/pacing.",
        "GIVEN docs/launch_policy.md exists WHEN reviewed THEN includes environments (DEV/STAGING/PAPER/LIVE).",
        "GIVEN evidence/phase0/policy/launch_policy_snapshot.md exists WHEN reviewed THEN is literal copy of docs."
      ],
      "steps": [
        "Create docs/launch_policy.md with allowed instruments and venues.",
        "Add allowed order types section.",
        "Add max position / max daily loss (capital stop).",
        "Add max order rate / pacing rule.",
        "Add environments section (DEV/STAGING/PAPER/LIVE with purpose).",
        "Copy full contents to evidence/phase0/policy/launch_policy_snapshot.md."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/launch_policy.md",
        "test -s evidence/phase0/policy/launch_policy_snapshot.md"
      ],
      "evidence": [
        "docs/launch_policy.md",
        "evidence/phase0/policy/launch_policy_snapshot.md"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_trading_policy.rs"
      ]
    },
    {
      "id": "S0-001",
      "priority": 199,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-B Environment Isolation",
      "category": "policy",
      "description": "Document environment isolation (separate keys/configs per env, no cross-env leakage).",
      "contract_refs": [
        "P0-B Environment Isolation"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/env_matrix.md",
          "evidence/phase0/env/env_matrix_snapshot.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN lists each environment (DEV/STAGING/PAPER/LIVE).",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows which exchange account per env.",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows key permissions per env.",
        "GIVEN docs/env_matrix.md exists WHEN reviewed THEN shows where secrets are stored.",
        "GIVEN evidence/phase0/env/env_matrix_snapshot.md exists WHEN reviewed THEN is literal copy of docs."
      ],
      "steps": [
        "Create docs/env_matrix.md with environment table.",
        "Add exchange account + API key per environment.",
        "Add permissions/scope per key (read-only vs trade vs withdraw).",
        "Add where secrets are stored (vault, env vars, etc.).",
        "Copy full contents to evidence/phase0/env/env_matrix_snapshot.md."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/env_matrix.md",
        "test -s evidence/phase0/env/env_matrix_snapshot.md"
      ],
      "evidence": [
        "docs/env_matrix.md",
        "evidence/phase0/env/env_matrix_snapshot.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S0-002",
      "priority": 198,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-C Keys & Secrets Baseline",
      "category": "policy",
      "description": "Document key creation rules, rotation plan, and prove least-privilege with JSON scope probe.",
      "contract_refs": [
        "P0-C Keys & Secrets Baseline"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/keys_and_secrets.md",
          "evidence/phase0/keys/key_scope_probe.json"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes key creation rules (least privilege).",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes rotation plan.",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes where secrets live.",
        "GIVEN docs/keys_and_secrets.md WHEN reviewed THEN includes LIVE key protection.",
        "GIVEN evidence/phase0/keys/key_scope_probe.json WHEN parsed THEN is valid JSON with required fields."
      ],
      "steps": [
        "Create docs/keys_and_secrets.md with key creation rules.",
        "Add rotation plan (who/when/how).",
        "Add where secrets live (what must never appear in repo).",
        "Add how LIVE keys are protected from local/dev usage.",
        "Execute key scope probe and record in JSON format.",
        "Verify JSON has required fields: env, exchange, key_id, scopes, withdraw_enabled, timestamp_utc, operator."
      ],
      "verify": [
        "./plans/verify.sh",
        "python -c \"import json; json.load(open('evidence/phase0/keys/key_scope_probe.json'))\"",
        "test -s docs/keys_and_secrets.md"
      ],
      "evidence": [
        "docs/keys_and_secrets.md",
        "evidence/phase0/keys/key_scope_probe.json"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [],
      "human_blocker": {
        "why": "Key scope probes require access to exchange APIs",
        "question": "Has key scope probe been executed and recorded as JSON?",
        "options": [
          "Yes - probe JSON recorded",
          "No - awaiting access"
        ],
        "recommended": "Execute probe and record in key_scope_probe.json",
        "unblock_steps": [
          "Get API access",
          "Run scope probe",
          "Record JSON with required fields"
        ]
      }
    },
    {
      "id": "S0-003",
      "priority": 197,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-D Break-Glass Runbook + Drill",
      "category": "policy",
      "description": "Create break-glass runbook and execute a recorded drill proving halt capability.",
      "contract_refs": [
        "P0-D Break-Glass Runbook"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "docs/break_glass_runbook.md",
          "evidence/phase0/break_glass/drill.md",
          "evidence/phase0/break_glass/log_excerpt.txt",
          "evidence/phase0/break_glass/runbook_snapshot.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has STOP TRADING steps.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has verify no further OPEN risk.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has verify risk reduction possible.",
        "GIVEN docs/break_glass_runbook.md WHEN reviewed THEN has escalation + notify.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has trigger scenario.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has time to halt.",
        "GIVEN evidence/phase0/break_glass/drill.md WHEN reviewed THEN has observed behavior.",
        "GIVEN evidence/phase0/break_glass/log_excerpt.txt WHEN reviewed THEN proves drill occurred."
      ],
      "steps": [
        "Create docs/break_glass_runbook.md with STOP TRADING steps (kill switch).",
        "Add how to verify no further OPEN risk.",
        "Add how to verify risk reduction still possible.",
        "Add escalation and who to notify.",
        "Copy runbook to evidence/phase0/break_glass/runbook_snapshot.md.",
        "Execute drill: simulate runaway order attempt.",
        "Record drill in evidence/phase0/break_glass/drill.md with trigger, time to halt, observed behavior.",
        "Capture log excerpt in evidence/phase0/break_glass/log_excerpt.txt."
      ],
      "verify": [
        "./plans/verify.sh",
        "test -s docs/break_glass_runbook.md",
        "test -s evidence/phase0/break_glass/drill.md",
        "test -s evidence/phase0/break_glass/log_excerpt.txt",
        "test -s evidence/phase0/break_glass/runbook_snapshot.md"
      ],
      "evidence": [
        "docs/break_glass_runbook.md",
        "evidence/phase0/break_glass/drill.md",
        "evidence/phase0/break_glass/log_excerpt.txt",
        "evidence/phase0/break_glass/runbook_snapshot.md"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "break_glass_drill_completed",
            "type": "gauge",
            "unit": "count",
            "labels": [],
            "note": "Evidence artifact: log_excerpt.txt proves drill occurred (1 when drill completed)"
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [],
      "human_blocker": {
        "why": "Drill requires human execution and observation",
        "question": "Has the break-glass drill been executed with witnesses?",
        "options": [
          "Yes - drill completed and recorded",
          "No - drill not yet executed"
        ],
        "recommended": "Execute drill in DEV/STAGING before marking done",
        "unblock_steps": [
          "Create runbook doc",
          "Execute drill",
          "Record in drill.md",
          "Capture log excerpt"
        ]
      }
    },
    {
      "id": "S0-004",
      "priority": 196,
      "phase": 0,
      "slice": 0,
      "slice_ref": "Slice 0 \u2014 Phase 0 Launch Policy & Ops Baseline",
      "story_ref": "P0-E Health Endpoint",
      "category": "infra",
      "description": "Implement health endpoint returning ok/build_id/contract_version.",
      "contract_refs": [
        "P0-E Health Endpoint Scaffolding",
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "Global Non\u2011Negotiables (apply to ALL stories)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/health.rs",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests/test_health.rs",
          "docs/health_endpoint.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN health endpoint called WHEN system healthy THEN returns ok=true, build_id, contract_version.",
        "GIVEN health command WHEN system healthy THEN exits 0.",
        "GIVEN docs/health_endpoint.md WHEN reviewed THEN documents command and format."
      ],
      "steps": [
        "Create docs/health_endpoint.md documenting the health command.",
        "Define expected output format (ok, build_id, contract_version).",
        "Implement health endpoint in soldier_infra.",
        "Wire health endpoint to CLI command.",
        "Implement test_health_endpoint_returns_required_fields.",
        "Implement test_health_command_exits_zero_when_healthy.",
        "Run tests and verify all pass."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_health"
      ],
      "evidence": [
        "cargo test output",
        "docs/health_endpoint.md"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "ok",
          "build_id",
          "contract_version"
        ],
        "status_contract_ats": [
          "AT-012"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_health.rs"
      ]
    },
    {
      "id": "S1-010",
      "priority": 88,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.0 Appendix A config defaults",
      "category": "infra",
      "description": "Apply Appendix A safety-critical defaults in infra config and verify missing-value behavior.",
      "contract_refs": [
        "CONTRACT.md Appendix A: Configuration Defaults (Safety-Critical Thresholds)",
        "CONTRACT.md AT-341",
        "CONTRACT.md AT-040",
        "Anchor-001",
        "Anchor-002",
        "Anchor-003",
        "Anchor-008",
        "Anchor-009",
        "Anchor-010",
        "Anchor-012",
        "Anchor-015",
        "Anchor-016",
        "Anchor-020",
        "Anchor-022",
        "VR-001",
        "VR-002",
        "VR-003",
        "VR-004a",
        "VR-004b",
        "VR-005",
        "VR-006",
        "VR-008",
        "VR-009",
        "VR-015",
        "VR-016",
        "VR-023"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.0 \u2014 Repo verification harness (plans/verify.sh) + safety-critical config defaults (Appendix A)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/config/**",
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/tests/**"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/**",
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN config omits instrument_cache_ttl_s WHEN defaults are applied THEN the TTL uses the Appendix A default of 3600s.",
        "GIVEN config omits the global evidence cooldown setting WHEN defaults are applied THEN the cooldown uses the Appendix A default of 120s.",
        "GIVEN config omits mm_util_kill WHEN defaults are applied THEN the kill threshold uses the Appendix A default of 0.95.",
        "GIVEN a safety-critical gate references a parameter without an Appendix A default WHEN the parameter is missing THEN the gate fails closed with a deterministic reason."
      ],
      "steps": [
        "Define a centralized defaults table covering Appendix A safety-critical parameters, including instrument_cache_ttl_s, evidenceguard_global_cooldown, and mm_util_kill.",
        "Create a config loader in crates/soldier_infra that applies Appendix A defaults when values are missing.",
        "Add a fail-closed path for safety-critical parameters that lack Appendix A defaults, surfacing a deterministic error.",
        "Create crates/soldier_infra/tests/test_config_defaults.rs with a test for missing instrument_cache_ttl_s and the global evidence cooldown applying defaults.",
        "Add a test case for missing mm_util_kill applying the Appendix A default.",
        "Add a test case for a missing non-Appendix A parameter to assert fail-closed behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_config_defaults"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_config_defaults output"
      ],
      "dependencies": [
        "S1-001"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-040",
        "AT-341"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "config_defaults_applied_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "config_key"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-001",
      "priority": 90,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.0 Workspace scaffolding",
      "category": "infra",
      "description": "Initialize the Rust workspace with soldier_core and soldier_infra crates.",
      "contract_refs": [
        "CONTRACT.md 0.X Repository Layout & Canonical Module Mapping (Non-Negotiable)",
        "CONTRACT.md AT-905"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md C) Entry Criteria"
      ],
      "scope": {
        "touch": [
          ".gitignore",
          "Cargo.toml",
          "crates/soldier_core/Cargo.toml",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_infra/Cargo.toml",
          "crates/soldier_infra/src/lib.rs"
        ],
        "avoid": [
          "artifacts/**",
          "python/**",
          "specs/**"
        ]
      },
      "acceptance": [
        "GIVEN the repo layout WHEN inspected THEN crates/soldier_core and crates/soldier_infra directories exist.",
        "GIVEN Cargo.toml is inspected WHEN reading workspace members THEN it includes crates/soldier_core and crates/soldier_infra.",
        "GIVEN the workspace is configured WHEN running `cargo test --workspace` THEN it builds and exits 0."
      ],
      "steps": [
        "Create the crates/ directory if it does not exist.",
        "Initialize crates/soldier_core as a Rust library crate.",
        "Initialize crates/soldier_infra as a Rust library crate.",
        "Create or update the root Cargo.toml with a workspace members list including both crates.",
        "Run `cargo test --workspace` to confirm the workspace builds."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "cargo test --workspace output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-905"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-011",
      "priority": 65,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Deribit instrument structs",
      "category": "infra",
      "description": "Define Deribit public instrument structs for metadata mapping.",
      "contract_refs": [
        "CONTRACT.md AT-333"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.1 \u2014 InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/Cargo.toml",
          "crates/soldier_infra/src/deribit/mod.rs",
          "crates/soldier_infra/src/deribit/public/mod.rs",
          "crates/soldier_infra/src/lib.rs"
        ],
        "avoid": [
          "crates/soldier_core/**"
        ]
      },
      "acceptance": [
        "GIVEN AT-333 requires InstrumentKind derivation from venue metadata WHEN the Deribit public instrument struct is defined THEN it MUST include the 'kind' field (option|future|option_combo) required for mapping to the contract InstrumentKind enum.",
        "GIVEN the contract OrderSize struct requires tick_size, amount_step, min_amount, and contract_multiplier (AT-333) WHEN the Deribit public instrument struct is defined THEN all four fields are present and deserializable from /public/get_instruments responses.",
        "GIVEN soldier_core will consume Deribit metadata (AT-333) WHEN the Deribit public module is compiled THEN the instrument structs are pub-exported from soldier_infra and importable by dependent crates."
      ],
      "steps": [
        "Define the minimal Deribit public instrument structs needed for mapping in crates/soldier_infra/src/deribit/public, including tick_size, amount_step, min_amount, and contract_multiplier.",
        "Add required serde derives for deserialization from Deribit API responses.",
        "Wire imports in crates/soldier_infra/src/deribit/mod.rs and src/lib.rs to expose the public module.",
        "Add basic unit tests or compile checks to verify the struct fields are correctly defined.",
        "Run cargo test -p soldier_infra to confirm the module compiles and is accessible."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra"
      ],
      "evidence": [
        "cargo test -p soldier_infra output"
      ],
      "dependencies": [
        "S1-001"
      ],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-333"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-002",
      "priority": 80,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 InstrumentKind and RiskState",
      "category": "execution",
      "description": "Implement InstrumentKind derivation and RiskState enum per contract definitions.",
      "contract_refs": [
        "CONTRACT.md AT-333"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.1 \u2014 InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/risk/state.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/src/venue/types.rs",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs"
        ],
        "avoid": [
          "crates/soldier_core/policy/**",
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN Deribit metadata for a USDC-margined perpetual WHEN deriving InstrumentKind THEN it returns linear_future.",
        "GIVEN metadata for option, perpetual, inverse_future, and linear_future instruments WHEN deriving InstrumentKind THEN it maps to the contract enum values.",
        "GIVEN instrument metadata from /public/get_instruments WHEN mapping to internal fields THEN tick_size, amount_step, min_amount, and contract_multiplier match the fetched values (test_instrument_metadata_uses_get_instruments).",
        "GIVEN the RiskState enum WHEN compiled THEN it includes Healthy, Degraded, Maintenance, and Kill variants."
      ],
      "steps": [
        "Define the RiskState enum in crates/soldier_core/src/risk/state.rs with the contract variants.",
        "Define the InstrumentKind enum in crates/soldier_core/src/venue/types.rs with contract values.",
        "Implement conversion logic from Deribit instrument metadata to InstrumentKind, including linear perpetual \u2192 linear_future and metadata field passthrough.",
        "Add unit tests in crates/soldier_core/tests/test_instrument_kind_mapping.rs for mapping behavior and metadata passthrough (test_instrument_metadata_uses_get_instruments).",
        "Wire any required imports so the new enums are accessible where used."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_kind_mapping"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_instrument_kind_mapping output"
      ],
      "dependencies": [
        "S1-011"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata).",
          "location": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata).",
          "anchor": "CONTRACT.md instrument_kind: one of `option | linear_future | inverse_future | perpetual` (derived from venue metadata)."
        }
      ],
      "enforcing_contract_ats": [
        "AT-333"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_instrument_kind_mapping.rs"
      ]
    },
    {
      "id": "S1-003",
      "priority": 70,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Instrument cache TTL",
      "category": "risk",
      "description": "Enforce InstrumentCache TTL and degrade RiskState on stale metadata.",
      "contract_refs": [
        "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
        "CONTRACT.md AT-104",
        "VR-013"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.1 \u2014 InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN cached instrument metadata older than the configured TTL WHEN accessed THEN RiskState::Degraded is returned for that lookup (test_stale_instrument_cache_sets_degraded).",
        "GIVEN cached metadata within TTL WHEN accessed THEN RiskState::Healthy is returned alongside the metadata.",
        "GIVEN instrument_cache_age_s > instrument_cache_ttl_s and an OPEN intent WHEN dispatch eligibility is checked THEN the OPEN is rejected and CLOSE/HEDGE/CANCEL remain allowed (test_instrument_cache_ttl_blocks_opens_allows_closes).",
        "GIVEN cache access WHEN processing THEN the cache age is compared against instrument_cache_ttl_s deterministically."
      ],
      "steps": [
        "Locate or create the InstrumentCache structure in crates/soldier_core/venue.",
        "Add timestamp tracking for cache insert/update and compute cache age on read; record instrument_cache_age_s and increment instrument_cache_hits_total.",
        "Compare cache age to TTL and return RiskState::Degraded when stale.",
        "Expose the cache freshness signal to dispatch eligibility checks so OPEN is rejected and CLOSE/HEDGE/CANCEL remain allowed when stale.",
        "Add unit tests in crates/soldier_core/tests/test_instrument_cache_ttl.rs for fresh vs stale behavior.",
        "Add a unit test for stale metadata blocking OPEN while allowing CLOSE/HEDGE/CANCEL.",
        "Add or update a test to assert cache age comparisons against instrument_cache_ttl_s are deterministic."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_cache_ttl"
      ],
      "evidence": [
        "Unit test asserts OPEN blocked and CLOSE/HEDGE/CANCEL allowed when metadata is stale",
        "Unit test asserts RiskState::Degraded on stale metadata",
        "Unit test asserts instrument_cache_ttl_s comparison is deterministic",
        "cargo test -p soldier_core --test test_instrument_cache_ttl output"
      ],
      "dependencies": [
        "S1-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
          "location": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
          "anchor": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement"
        }
      ],
      "enforcing_contract_ats": [
        "AT-104"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "instrument_cache_hits_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          },
          {
            "name": "instrument_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "RiskState::Healthy",
        "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
      ]
    },
    {
      "id": "S1-006",
      "priority": 65,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.1 Instrument cache TTL observability",
      "category": "risk",
      "description": "Add required TTL observability hooks for instrument cache freshness.",
      "contract_refs": [
        "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
        "VR-013"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.1 \u2014 InstrumentKind derivation + instrument cache TTL"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN a TTL breach WHEN processing THEN a structured log InstrumentCacheTtlBreach{instrument_id, age_s, ttl_s} is emitted.",
        "GIVEN any cache access WHEN processing THEN instrument_cache_hits_total increments and instrument_cache_age_s is updated.",
        "GIVEN a stale access WHEN processing THEN instrument_cache_stale_total increments.",
        "GIVEN a metadata refresh failure WHEN processing THEN instrument_cache_refresh_errors_total increments."
      ],
      "steps": [
        "Emit a structured log InstrumentCacheTtlBreach with instrument_id, age_s, ttl_s on staleness.",
        "Increment instrument_cache_hits_total on every cache access.",
        "Update instrument_cache_age_s gauge with computed cache age.",
        "Increment instrument_cache_stale_total on staleness.",
        "Increment instrument_cache_refresh_errors_total when a metadata refresh fails.",
        "Add test assertions in crates/soldier_core/tests/test_instrument_cache_ttl.rs for the log event.",
        "Add test assertions for metric increments and gauge updates using an in-memory metrics registry or mock."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_instrument_cache_ttl"
      ],
      "evidence": [
        "Log capture shows InstrumentCacheTtlBreach with instrument_id, age_s, ttl_s",
        "Unit test asserts instrument_cache_age_s gauge update",
        "Unit test asserts instrument_cache_hits_total and instrument_cache_stale_total increments",
        "Unit test asserts instrument_cache_refresh_errors_total increment",
        "cargo test -p soldier_core --test test_instrument_cache_ttl output"
      ],
      "dependencies": [
        "S1-003"
      ],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
          "location": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement",
          "anchor": "CONTRACT.md 1.0.X Instrument Metadata Freshness (Instrument Cache TTL) \u2014 MUST implement"
        }
      ],
      "enforcing_contract_ats": [
        "AT-104"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_INPUT_MISSING_OR_STALE"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "instrument_cache_hits_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          },
          {
            "name": "instrument_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          },
          {
            "name": "instrument_cache_stale_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_instrument_cache_ttl.rs"
      ]
    },
    {
      "id": "S1-004",
      "priority": 60,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize canonical sizing",
      "category": "execution",
      "description": "Implement OrderSize canonical sizing with deterministic notional_usd using the discovery report.",
      "contract_refs": [
        "CONTRACT.md OrderSize struct (MUST implement):",
        "CONTRACT.md 1.0 Instrument Units & Notional Invariants (Deribit Quantity Contract)"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.2 \u2014 OrderSize canonical sizing + notional invariant"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/venue/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN instrument_kind option or linear_future WHEN building OrderSize THEN qty_coin is canonical and notional_usd = qty_coin * index_price.",
        "GIVEN instrument_kind option WHEN building OrderSize THEN qty_usd is unset.",
        "GIVEN instrument_kind perpetual or inverse_future WHEN building OrderSize THEN qty_usd is canonical and notional_usd = qty_usd.",
        "GIVEN any OrderSize WHEN built THEN notional_usd is always populated and internal fields are consistent with the contract invariants."
      ],
      "steps": [
        "Review docs/order_size_discovery.md for current gaps and proposed tests.",
        "Create crates/soldier_core/src/execution/order_size.rs if missing.",
        "Define the OrderSize struct with contracts, qty_coin, qty_usd, and notional_usd.",
        "Implement a constructor/builder that computes canonical units based on InstrumentKind.",
        "Ensure option sizing uses qty_coin and leaves qty_usd unset.",
        "Populate notional_usd deterministically using index_price for coin-sized instruments.",
        "Add a debug log OrderSizeComputed{instrument_kind, notional_usd}.",
        "Add unit tests in crates/soldier_core/tests/test_order_size.rs for canonical sizing."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_order_size"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_order_size output"
      ],
      "dependencies": [
        "S1-002",
        "S1-008"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md OrderSize struct (MUST implement):",
          "location": "CONTRACT.md OrderSize struct (MUST implement):",
          "anchor": "CONTRACT.md OrderSize struct (MUST implement):"
        }
      ],
      "enforcing_contract_ats": [
        "AT-277"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "order_size_computed_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_order_size.rs"
      ]
    },
    {
      "id": "S1-005",
      "priority": 50,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher amount mapping",
      "category": "execution",
      "description": "Map OrderSize to Deribit request amounts using the discovery report.",
      "contract_refs": [
        "CONTRACT.md Dispatcher Rules (Deribit request mapping):"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.3 \u2014 Dispatcher amount mapping + mismatch reject\u2192Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/risk/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN option or linear_future OrderSize WHEN mapping to an outbound Deribit request THEN it sets exactly one amount field using qty_coin.",
        "GIVEN perpetual or inverse_future OrderSize WHEN mapping to an outbound Deribit request THEN it sets exactly one amount field using qty_usd.",
        "GIVEN any OrderSize WHEN mapping THEN exactly one canonical amount field is set and the other is unset.",
        "GIVEN intent classification CLOSE/HEDGE WHEN mapping THEN reduce_only=true; GIVEN OPEN THEN reduce_only=false or omitted."
      ],
      "steps": [
        "Review docs/dispatch_map_discovery.md for current gaps and proposed tests.",
        "Create or update crates/soldier_core/src/execution/dispatch_map.rs with OrderSize mapping logic.",
        "Implement the rule: exactly one canonical amount field is sent per instrument_kind.",
        "Ensure outbound request uses qty_coin for option/linear_future and qty_usd for perpetual/inverse_future.",
        "Map reduce_only from intent classification only (CLOSE/HEDGE=true, OPEN=false or omitted).",
        "Add unit tests in crates/soldier_core/tests/test_dispatch_map.rs for amount field selection.",
        "Add a negative test asserting no second amount field is set."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_map"
      ],
      "evidence": [
        "Unit test asserts reduce_only mapping by intent classification",
        "cargo test -p soldier_core --test test_dispatch_map output"
      ],
      "dependencies": [
        "S1-004",
        "S1-009"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
          "location": "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
          "anchor": "CONTRACT.md Dispatcher Rules (Deribit request mapping):"
        }
      ],
      "enforcing_contract_ats": [
        "AT-277"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_dispatch_map.rs"
      ]
    },
    {
      "id": "S1-007",
      "priority": 55,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher mismatch rejection",
      "category": "execution",
      "description": "Reject contract/amount mismatches and emit mismatch metrics.",
      "contract_refs": [
        "CONTRACT.md AT-920"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.3 \u2014 Dispatcher amount mapping + mismatch reject\u2192Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/risk/**",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN AT-920 requires rejecting intent on contracts/amount mismatch and setting RiskState::Degraded WHEN contracts vs canonical amount differ by more than contracts_amount_match_tolerance=0.001 THEN the intent is rejected with RejectReason::UnitMismatch AND RiskState::Degraded is returned (enforcing fail-closed per contract).",
        "GIVEN AT-920 requires observability of mismatch rejections WHEN a mismatch rejection occurs THEN order_intent_reject_unit_mismatch_total counter increments by 1.",
        "GIVEN the contract requires deterministic error propagation (AT-920) WHEN a mismatch rejection occurs THEN the error is surfaced to callers with RejectReason::UnitMismatch and includes the computed mismatch delta."
      ],
      "steps": [
        "Validate contracts vs canonical amount using contracts_amount_match_tolerance=0.001 and return an error with RiskState::Degraded on mismatch.",
        "Define a deterministic error reason for unit mismatches to surface to callers.",
        "Increment order_intent_reject_unit_mismatch_total for mismatch rejections.",
        "Add unit tests in crates/soldier_core/tests/test_dispatch_map.rs for mismatch rejection behavior.",
        "Add or update unit tests in crates/soldier_core/tests/test_order_size.rs for mismatch cases.",
        "Assert the metric increment via an in-memory metrics registry or mock."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_map",
        "cargo test -p soldier_core --test test_order_size"
      ],
      "evidence": [
        "Unit test asserts contracts_amount_match_tolerance=0.001 applied",
        "Unit test asserts order_intent_reject_unit_mismatch_total increment",
        "cargo test -p soldier_core --test test_dispatch_map output",
        "cargo test -p soldier_core --test test_order_size output"
      ],
      "dependencies": [
        "S1-005"
      ],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`",
          "location": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`",
          "anchor": "CONTRACT.md If a mismatch is detected: **reject the intent** and set `RiskState::Degraded`"
        }
      ],
      "enforcing_contract_ats": [
        "AT-920"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "UnitMismatch"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "order_intent_reject_unit_mismatch_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "crates/soldier_core/tests/test_dispatch_map.rs",
        "crates/soldier_core/tests/test_order_size.rs"
      ]
    },
    {
      "id": "S1-008",
      "priority": 95,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.2 OrderSize discovery",
      "category": "qa",
      "description": "Discover current OrderSize logic and document gaps vs contract before implementation.",
      "contract_refs": [
        "CONTRACT.md 1.0 Instrument Units & Notional Invariants (Deribit Quantity Contract)",
        "CONTRACT.md OrderSize struct (MUST implement):",
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.2 \u2014 OrderSize canonical sizing + notional invariant"
      ],
      "scope": {
        "touch": [
          "docs/order_size_discovery.md"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN the current OrderSize implementation WHEN inspected THEN docs/order_size_discovery.md lists current fields, call sites, and gaps vs the contract OrderSize struct.",
        "GIVEN contract unit invariants WHEN inspected THEN docs/order_size_discovery.md lists required tests to add for canonical sizing.",
        "GIVEN the discovery report WHEN reviewed THEN it names the minimal implementation diff needed for OrderSize canonical sizing."
      ],
      "steps": [
        "Locate current OrderSize logic and any related helpers in the codebase.",
        "Identify call sites that construct OrderSize or size fields.",
        "Draft docs/order_size_discovery.md with: current fields, gaps vs contract, and proposed tests.",
        "List the minimal diff required to align OrderSize with contract invariants.",
        "Keep the report scoped to OrderSize and sizing invariants only."
      ],
      "verify": [
        "./plans/verify.sh",
        "rg -n \"OrderSize\" docs/order_size_discovery.md",
        "test -f docs/order_size_discovery.md"
      ],
      "evidence": [
        "docs/order_size_discovery.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-218",
        "AT-219",
        "AT-343",
        "AT-216"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "StatusEndpoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-009",
      "priority": 85,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.3 Dispatcher mapping discovery",
      "category": "qa",
      "description": "Discover current dispatcher mapping logic and document gaps vs contract before implementation.",
      "contract_refs": [
        "CONTRACT.md Dispatcher Rules (Deribit request mapping):",
        "Anchor-021",
        "VR-024"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.3 \u2014 Dispatcher amount mapping + mismatch reject\u2192Degraded"
      ],
      "scope": {
        "touch": [
          "docs/dispatch_map_discovery.md"
        ],
        "avoid": [
          "crates/**",
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN the current dispatch mapping WHEN inspected THEN docs/dispatch_map_discovery.md lists current amount field logic and contract gaps.",
        "GIVEN contract mapping rules WHEN inspected THEN docs/dispatch_map_discovery.md lists tests to add for canonical amount selection.",
        "GIVEN the discovery report WHEN reviewed THEN it names the minimal implementation diff required for dispatcher mapping."
      ],
      "steps": [
        "Locate current dispatch mapping logic in the codebase.",
        "Identify how outbound amount fields are chosen today.",
        "Draft docs/dispatch_map_discovery.md with: current logic, gaps vs contract, and proposed tests.",
        "List the minimal diff required to align mapping with contract rules.",
        "Keep the report scoped to dispatcher mapping only."
      ],
      "verify": [
        "./plans/verify.sh",
        "rg -n \"dispatch\" docs/dispatch_map_discovery.md",
        "test -f docs/dispatch_map_discovery.md"
      ],
      "evidence": [
        "docs/dispatch_map_discovery.md"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-218",
        "AT-219",
        "AT-343",
        "AT-216"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "StatusEndpoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": []
    },
    {
      "id": "S1-012",
      "priority": 97,
      "phase": 1,
      "slice": 1,
      "slice_ref": "Slice 1 \u2014 Instrument Units \\+ Dispatcher Invariants",
      "story_ref": "S1.12 F1 cert tooling",
      "category": "tooling",
      "description": "Implement f1_certify tooling and F1_CERT artifacts required for promotion verify.",
      "contract_refs": [
        "CONTRACT.md f1_cert (from artifacts/F1_CERT.json: {status, generated_ts_ms, build_id, runtime_config_hash, contract_version})",
        "CONTRACT.md python/tools/f1_certify.py",
        "CONTRACT.md outputs artifacts/F1_CERT.json and artifacts/F1_CERT.md",
        "CONTRACT.md artifacts/F1_CERT.json MUST include (minimum): { status, generated_ts_ms, build_id, runtime_config_hash, contract_version }"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md PL-10 \u2014 f1_certify CLI + F1_CERT schema completeness (contract)",
        "IMPLEMENTATION_PLAN.md Slice 1 \u2014 Instrument Units + Dispatcher Invariants / S1.12 \u2014 F1 cert tooling (moved from PL-10; Slice 1 exception)"
      ],
      "scope": {
        "touch": [
          "artifacts/F1_CERT.json",
          "artifacts/F1_CERT.md",
          "python/tests/test_f1_certify.py",
          "python/tools/f1_certify.py",
          "scripts/f1_certify.py"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN python/tools/f1_certify.py WHEN run with --window=24h and --out artifacts/F1_CERT.json THEN it writes artifacts/F1_CERT.json with required keys {status, generated_ts_ms, build_id, runtime_config_hash, contract_version, expires_at_ts_ms, release_gate_metrics}.",
        "GIVEN scripts/f1_certify.py WHEN invoked with the same CLI args THEN it delegates to python/tools/f1_certify.py and produces identical outputs.",
        "GIVEN a successful run WHEN artifacts/F1_CERT.json is written THEN artifacts/F1_CERT.md summary is also written."
      ],
      "steps": [
        "Create python/tools/f1_certify.py with CLI --window and --out.",
        "Generate artifacts/F1_CERT.json with required schema keys and PASS/FAIL status based on available metrics.",
        "Write artifacts/F1_CERT.md summary alongside F1_CERT.json.",
        "Add scripts/f1_certify.py wrapper that delegates to python/tools/f1_certify.py with identical CLI args.",
        "Add python/tests/test_f1_certify.py covering required keys and summary output."
      ],
      "verify": [
        "./plans/verify.sh",
        "bash -n plans/verify.sh"
      ],
      "evidence": [
        "artifacts/F1_CERT.json",
        "artifacts/F1_CERT.md",
        "python/tests/test_f1_certify.py"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-003",
        "AT-412",
        "AT-113",
        "AT-012"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "release_gate_metrics.fee_drag_ratio",
            "type": "gauge",
            "unit": "pct",
            "labels": []
          },
          {
            "name": "release_gate_metrics.replay_coverage_pct",
            "type": "gauge",
            "unit": "pct",
            "labels": []
          },
          {
            "name": "release_gate_metrics.atomic_naked_events_24h",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "python/tests/test_f1_certify.py"
      ]
    },
    {
      "id": "S2-000",
      "priority": 100,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.1 Quantization rounding",
      "category": "execution",
      "description": "Implement deterministic quantization for qty and limit price with safe rounding.",
      "contract_refs": [
        "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
        "AT-021",
        "AT-020"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency / S2.1 \u2014 Integer tick/step quantization (safer direction)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/quantize.rs",
          "crates/soldier_core/tests/test_quantize.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/idempotency/**"
        ]
      },
      "acceptance": [
        "GIVEN raw_qty and amount_step WHEN quantizing THEN qty_steps = floor(raw_qty / amount_step) and qty_q = qty_steps * amount_step.",
        "GIVEN a BUY raw_limit_price and tick_size WHEN quantizing THEN price_ticks = floor(raw_limit_price / tick_size) and limit_price_q = price_ticks * tick_size; GIVEN SELL THEN price_ticks = ceil(raw_limit_price / tick_size).",
        "GIVEN qty_q < min_amount WHEN quantizing THEN the intent is rejected with TooSmallAfterQuantization."
      ],
      "steps": [
        "Implement quantize helpers to read tick_size, amount_step, and min_amount from instrument metadata.",
        "Compute qty_steps and price_ticks as integers using amount_step and tick_size with directional rounding by side.",
        "Derive qty_q and limit_price_q from qty_steps and price_ticks.",
        "Add a rejection path when qty_q < min_amount with an explicit error type.",
        "Add counter quantization_reject_too_small_total for rejection metrics.",
        "Add unit tests in crates/soldier_core/tests/test_quantize.rs for rounding and rejection behavior.",
        "Ensure integer tick/step values are returned for downstream idempotency hashing."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_quantize"
      ],
      "evidence": [
        "Unit test asserts metric increment via in-memory metrics registry/mock",
        "cargo test -p soldier_core --test test_quantize output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
          "location": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
          "anchor": "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-020",
        "AT-021"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::TooSmallAfterQuantization"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "quantization_reject_too_small_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_quantize.rs"
      ]
    },
    {
      "id": "S2-001",
      "priority": 90,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.2 Intent hash from quantized fields",
      "category": "durability",
      "description": "Compute intent_hash from quantized fields only and exclude timestamps.",
      "contract_refs": [
        "CONTRACT.md 1.1 Labeling & Idempotency Contract",
        "CONTRACT.md 1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)",
        "AT-020",
        "Anchor-017",
        "VR-017"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency / S2.2 \u2014 Intent hash from quantized fields only"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/idempotency/hash.rs",
          "crates/soldier_core/src/idempotency/mod.rs",
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/tests/test_idempotency.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/execution/quantize.rs"
        ]
      },
      "acceptance": [
        "GIVEN two codepaths that yield identical quantized fields WHEN hashing THEN the intent_hash values are identical.",
        "GIVEN an intent with time-of-day timestamps WHEN hashing THEN timestamps are excluded from the hash input.",
        "GIVEN quantized qty_steps and price_ticks WHEN hashing THEN those integer values (plus stable strings) are used, not raw f64."
      ],
      "steps": [
        "Implement or update the intent_hash function in crates/soldier_core/src/idempotency/hash.rs to accept quantized integer inputs.",
        "Remove any inclusion of wall-clock timestamps from the hash input.",
        "Use qty_steps and price_ticks (integers) alongside instrument, side, group_id, and leg_idx in the hash material.",
        "Add unit tests in crates/soldier_core/tests/test_idempotency.rs for deterministic hashing.",
        "Ensure callers pass quantized integer fields into the hashing function."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_idempotency"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_idempotency output"
      ],
      "dependencies": [
        "S2-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1 Labeling & Idempotency Contract",
          "location": "CONTRACT.md 1.1 Labeling & Idempotency Contract",
          "anchor": "CONTRACT.md 1.1 Labeling & Idempotency Contract"
        }
      ],
      "enforcing_contract_ats": [
        "AT-020"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_idempotency.rs"
      ]
    },
    {
      "id": "S2-002",
      "priority": 80,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.3 Compact label schema",
      "category": "durability",
      "description": "Implement compact label encode/decode with 64-character limit enforcement.",
      "contract_refs": [
        "CONTRACT.md \u00a71.1 Labeling & Idempotency Contract",
        "AT-216",
        "AT-217"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency / S2.3 \u2014 Compact label schema encode/decode (\u226464 chars)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/label.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_label.rs"
        ],
        "avoid": [
          "crates/soldier_core/src/recovery/**"
        ]
      },
      "acceptance": [
        "GIVEN strat_id, group_id, leg_idx, and intent_hash WHEN encoding THEN the label matches s4:{sid8}:{gid12}:{li}:{ih16} and is \u2264 64 chars.",
        "GIVEN a compact label WHEN decoding THEN sid8, gid12, leg_idx, and ih16 are parsed correctly.",
        "GIVEN a computed s4 label would exceed 64 chars WHEN encoding THEN the intent is rejected with Rejected(LabelTooLong), RiskState::Degraded is set, and no dispatch occurs (no truncation)."
      ],
      "steps": [
        "Implement label encoding in crates/soldier_core/src/execution/label.rs to produce sid8, gid12, and ih16.",
        "Enforce the \u226464 character limit; if the computed label would exceed 64 chars, reject with LabelTooLong and set RiskState::Degraded (no truncation).",
        "Implement label decoding to parse sid8, gid12, leg_idx, and ih16.",
        "Add unit tests in crates/soldier_core/tests/test_label.rs for length limits and parsing.",
        "Ensure encode/decode round-trips for valid inputs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_label"
      ],
      "evidence": [
        "Test assertions for LabelTooLong rejection and label parsing",
        "cargo test -p soldier_core --test test_label output"
      ],
      "dependencies": [
        "S2-001"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md \u00a71.1 Labeling & Idempotency Contract",
          "location": "CONTRACT.md \u00a71.1 Labeling & Idempotency Contract",
          "anchor": "AT-216"
        }
      ],
      "enforcing_contract_ats": [
        "AT-216",
        "AT-217"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::LabelTooLong"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-216",
          "AT-217"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_label.rs"
      ]
    },
    {
      "id": "S2-003",
      "priority": 70,
      "phase": 1,
      "slice": 2,
      "slice_ref": "Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency",
      "story_ref": "S2.4 Label match disambiguation",
      "category": "risk",
      "description": "Disambiguate label matches deterministically and degrade on ambiguity.",
      "contract_refs": [
        "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
        "AT-022",
        "Anchor-001",
        "Anchor-019",
        "VR-021",
        "VR-022"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 2 \u2014 Quantization \\+ Labeling \\+ Idempotency / S2.4 \u2014 Label match disambiguation; ambiguity\u2192Degraded"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/lib.rs",
          "crates/soldier_core/src/recovery/**",
          "crates/soldier_core/tests/test_label_match.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/execution/**"
        ]
      },
      "acceptance": [
        "GIVEN multiple intents sharing gid12 and leg_idx WHEN matching THEN tie-breakers are applied in order: ih16, instrument, side, qty_q.",
        "GIVEN ambiguity remains after tie-breakers WHEN matching THEN RiskState::Degraded is returned and no intent is matched (fail-closed).",
        "GIVEN a single clear candidate WHEN matching THEN the matched intent is returned deterministically."
      ],
      "steps": [
        "Parse labels into sid8, gid12, leg_idx, and ih16 in crates/soldier_core/src/recovery/label_match.rs.",
        "Build the candidate set by gid12 and leg_idx.",
        "Apply the tie-breakers in the contract order: ih16, instrument, side, qty_q.",
        "On unresolved ambiguity, return a Degraded outcome and increment label_match_ambiguity_total.",
        "Add unit tests in crates/soldier_core/tests/test_label_match.rs for disambiguation and ambiguity cases.",
        "Ensure the matching result is deterministic for identical inputs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_label_match"
      ],
      "evidence": [
        "Unit test asserts metric increment via in-memory metrics registry/mock",
        "cargo test -p soldier_core --test test_label_match output"
      ],
      "dependencies": [
        "S2-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
          "location": "CONTRACT.md 1.1.2 Label Parse + Disambiguation (Collision-Safe)",
          "anchor": "AT-022"
        }
      ],
      "enforcing_contract_ats": [
        "AT-022"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "DEGRADED_LABEL_AMBIGUITY"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "label_match_ambiguity_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-022"
        ]
      },
      "implementation_tests": [
        "RiskState::Degraded",
        "crates/soldier_core/tests/test_label_match.rs"
      ]
    },
    {
      "id": "S3-000",
      "priority": 100,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed)",
      "story_ref": "S3.1 Preflight guard",
      "category": "execution",
      "description": "Implement order-type preflight rules for market/stop/linked orders across instruments.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-013",
        "AT-023",
        "AT-025",
        "AT-026",
        "AT-027",
        "AT-004",
        "AT-016",
        "AT-017",
        "AT-018",
        "AT-019",
        "AT-913",
        "AT-914",
        "AT-915",
        "Anchor-013",
        "Anchor-014",
        "Anchor-023",
        "VR-025",
        "VR-026",
        "VR-027"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed) / S3.1 \u2014 Preflight guard (market/stop/linked rules)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/order_type_guard.rs",
          "crates/soldier_core/src/execution/preflight.rs",
          "crates/soldier_core/tests/test_preflight.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/src/venue/**",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN instrument_kind=option WHEN order_type is market or stop or trigger fields are present THEN preflight rejects the intent deterministically.",
        "GIVEN instrument_kind in {linear_future,inverse_future,perpetual} WHEN order_type is market OR stop without trigger THEN preflight rejects the intent deterministically.",
        "GIVEN linked_order_type is set and linked orders are not explicitly enabled WHEN preflight runs THEN it rejects the intent and the preflight tests pass.",
        "GIVEN intent construction via build_order_intent WHEN preflight runs THEN it is invoked through a single shared preflight entrypoint (no bypass)."
      ],
      "steps": [
        "Create execution/preflight.rs and execution/order_type_guard.rs and wire them into crates/soldier_core/src/execution/mod.rs.",
        "Implement preflight checks for options and futures/perps per contract, returning explicit rejection reasons.",
        "Reject any linked_order_type unless feature-flagged and capability-enabled (default false).",
        "Add preflight_reject_total{reason} counter for rejects.",
        "Add unit tests in crates/soldier_core/tests/test_preflight.rs for market, stop, linked, and trigger requirements.",
        "Ensure preflight is invoked before any API dispatch path in the execution module.",
        "Expose a single preflight entrypoint (e.g., preflight_intent) and wire build_order_intent to call it."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_preflight"
      ],
      "evidence": [
        "Unit test asserts reject reasons for market/stop/linked orders",
        "cargo test -p soldier_core --test test_preflight output"
      ],
      "dependencies": [
        "S2-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-013"
        }
      ],
      "enforcing_contract_ats": [
        "AT-013",
        "AT-023",
        "AT-025",
        "AT-026"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "preflight_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_preflight.rs"
      ]
    },
    {
      "id": "S3-001",
      "priority": 90,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed)",
      "story_ref": "S3.2 Post-only crossing guard",
      "category": "execution",
      "description": "Reject post-only orders that would cross the book deterministically.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-916"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed) / S3.2 \u2014 Post\u2011only crossing guard"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/post_only_guard.rs",
          "crates/soldier_core/tests/test_post_only_guard.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/src/venue/**",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN post_only=true and the limit price would cross the touch WHEN preflight runs THEN it rejects the intent deterministically.",
        "GIVEN post_only=true and the limit price does not cross the touch WHEN preflight runs THEN it allows the intent to pass.",
        "GIVEN post_only crossing scenarios WHEN running tests THEN test_post_only_crossing_rejected passes."
      ],
      "steps": [
        "Create execution/post_only_guard.rs and wire it into crates/soldier_core/src/execution/mod.rs.",
        "Implement crossing detection using best bid/ask touch prices and reject when post_only would cross.",
        "Integrate the post-only guard into the preflight sequence.",
        "Add counter post_only_cross_reject_total for reject metrics.",
        "Add unit tests in crates/soldier_core/tests/test_post_only_guard.rs for crossing and non-crossing cases."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_post_only_guard"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_post_only_guard output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-916"
        }
      ],
      "enforcing_contract_ats": [
        "AT-916"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "post_only_cross_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_post_only_guard.rs"
      ]
    },
    {
      "id": "S3-002",
      "priority": 80,
      "phase": 1,
      "slice": 3,
      "slice_ref": "Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed)",
      "story_ref": "S3.3 Capabilities matrix + feature flags",
      "category": "execution",
      "description": "Implement venue capabilities to gate linked/OCO orders behind explicit flags.",
      "contract_refs": [
        "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
        "AT-028",
        "AT-004",
        "AT-915",
        "Anchor-023",
        "VR-026",
        "VR-027",
        "VR-028"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 3 \u2014 Order\u2011Type Preflight \\+ Venue Capabilities (artifact\u2011backed) / S3.3 \u2014 Capabilities matrix \\+ feature flags"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/venue/capabilities.rs",
          "crates/soldier_core/src/venue/mod.rs",
          "crates/soldier_core/tests/test_capabilities.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/execution/**",
          "crates/soldier_core/src/venue/cache.rs",
          "crates/soldier_core/src/venue/types.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_infra/**"
        ]
      },
      "acceptance": [
        "GIVEN default configuration WHEN computing capabilities THEN linked/OCO support is false for all instruments.",
        "GIVEN a venue capability and feature flag are both enabled WHEN computing capabilities THEN linked/OCO support is true.",
        "GIVEN the default configuration WHEN running tests THEN test_oco_not_supported passes."
      ],
      "steps": [
        "Create venue/capabilities.rs with a capabilities struct and evaluation helpers.",
        "Expose a feature flag (ENABLE_LINKED_ORDERS_FOR_BOT) to gate linked/OCO support.",
        "Default linked_orders_supported to false unless both capability and feature flag are true.",
        "Add unit tests in crates/soldier_core/tests/test_capabilities.rs for default and enabled behavior.",
        "Wire capabilities into venue module exports for consumption by preflight."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_capabilities"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_capabilities output"
      ],
      "dependencies": [
        "S3-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "location": "CONTRACT.md 1.4.4 Deribit Order-Type Preflight Guard (Artifact-Backed)",
          "anchor": "AT-028"
        }
      ],
      "enforcing_contract_ats": [
        "AT-028",
        "AT-004",
        "AT-915"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_capabilities.rs"
      ]
    },
    {
      "id": "S4-000",
      "priority": 100,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry",
      "story_ref": "S4.1 WAL append + replay no-resend",
      "category": "durability",
      "description": "Persist intents to a durable WAL and replay without resending after crash.",
      "contract_refs": [
        "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
        "CONTRACT.md \u00a72.4.1 WAL Writer Isolation (Hot Loop Protection)",
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234",
        "Anchor-004",
        "Anchor-005",
        "Anchor-006",
        "VR-010",
        "VR-014"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry / S4.1 \u2014 WAL append \\+ replay no-resend"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/src/store/**",
          "crates/soldier_infra/tests/**"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN an intent is appended to the durable ledger before dispatch WHEN the system restarts THEN the intent is not resent.",
        "GIVEN the system restarts WHEN reconstructing state from the durable ledger THEN in-flight intents are rebuilt without duplicate dispatch.",
        "GIVEN a recorded intent WHEN persisted THEN the record includes intent_hash, group_id, leg_idx, instrument, side, qty_steps or qty_q, limit_price_q or price_ticks, tls_state, created_ts, sent_ts, ack_ts, last_fill_ts, and exchange_order_id when available.",
        "GIVEN ledger append fails WHEN dispatch is attempted THEN the OPEN intent is rejected and the error counter increments.",
        "GIVEN the WAL writer queue is full WHEN an append is attempted THEN the append returns immediately with an error (hot loop not blocked)."
      ],
      "steps": [
        "Create crates/soldier_infra/src/store/ledger.rs with append + replay primitives.",
        "Wire the store module into crates/soldier_infra/src/lib.rs.",
        "Record intents before dispatch (RecordedBeforeDispatch) and mark replay outcomes.",
        "Define the minimum persisted intent schema in ledger storage comments and enforce it in the record struct.",
        "Add unit tests in crates/soldier_infra/tests/test_ledger_replay.rs for no-resend after crash.",
        "Document WAL initialization and replay expectations in module-level comments."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_ledger_replay"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_ledger_replay output"
      ],
      "dependencies": [
        "S3-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
          "location": "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
          "anchor": "AT-935"
        }
      ],
      "enforcing_contract_ats": [
        "AT-935",
        "AT-906"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "EXEC_WAL_WRITE_FAILED"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [
        "backpressure"
      ],
      "observability": {
        "metrics": [
          {
            "name": "wal_write_errors",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_ledger_replay.rs"
      ]
    },
    {
      "id": "S4-001",
      "priority": 90,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry",
      "story_ref": "S4.2 TLSM out-of-order events",
      "category": "execution",
      "description": "Handle fill-before-ack and out-of-order TLSM events without panic.",
      "contract_refs": [
        "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
        "CONTRACT.md 2.4 Durable Intent Ledger (WAL Truth Source)",
        "AT-230",
        "AT-210",
        "Anchor-011"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry / S4.2 \u2014 TLSM out\u2011of\u2011order events (fill-before-ack)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/state.rs",
          "crates/soldier_core/src/execution/tlsm.rs",
          "crates/soldier_core/tests/test_tlsm.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/src/execution/dispatch_map.rs",
          "crates/soldier_core/src/execution/order_size.rs",
          "crates/soldier_core/tests/test_dispatch_map.rs",
          "crates/soldier_core/tests/test_idempotency.rs",
          "crates/soldier_core/tests/test_instrument_cache_ttl.rs",
          "crates/soldier_core/tests/test_instrument_kind_mapping.rs",
          "crates/soldier_core/tests/test_label.rs",
          "crates/soldier_core/tests/test_label_match.rs",
          "crates/soldier_core/tests/test_order_size.rs",
          "crates/soldier_core/tests/test_quantize.rs"
        ]
      },
      "acceptance": [
        "GIVEN a fill arrives before an ack WHEN processing TLSM events THEN no panic occurs and the final state is Filled.",
        "GIVEN out-of-order TLSM events WHEN applied THEN transitions converge to the correct terminal state deterministically.",
        "GIVEN TLSM transitions are applied WHEN events process THEN each transition is appended to the durable ledger immediately."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/state.rs and tlsm.rs to model TLSM transitions.",
        "Wire TLSM modules into crates/soldier_core/src/execution/mod.rs.",
        "Implement out-of-order handling (fill-before-ack) without panics.",
        "Append each transition to WAL via the infra ledger adapter.",
        "Add unit tests in crates/soldier_core/tests/test_tlsm.rs for fill-before-ack behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_tlsm"
      ],
      "evidence": [
        "cargo test -p soldier_core --test test_tlsm output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
          "location": "CONTRACT.md 2.1 Trade Lifecycle State Machine (TLSM)",
          "anchor": "AT-230"
        }
      ],
      "enforcing_contract_ats": [
        "AT-230",
        "AT-210"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_tlsm.rs"
      ]
    },
    {
      "id": "S4-002",
      "priority": 80,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry",
      "story_ref": "S4.3 Trade-ID registry dedupe",
      "category": "durability",
      "description": "Persist processed trade IDs to prevent duplicate processing.",
      "contract_refs": [
        "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
        "AT-269",
        "AT-270",
        "Anchor-007",
        "VR-022"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry / S4.3 \u2014 Trade\u2011ID registry dedupe"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/src/store/**",
          "crates/soldier_infra/tests/**"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN a trade_id already recorded WHEN handling a trade event THEN it is a NOOP and no duplicate updates occur.",
        "GIVEN a new trade_id WHEN processing a trade THEN trade_id is appended to the durable ledger before applying updates.",
        "GIVEN a restart WHEN the same trade_id is seen again THEN it is ignored due to the registry.",
        "GIVEN concurrent events for the same trade_id WHEN inserting THEN the registry insert is atomic and only one apply occurs."
      ],
      "steps": [
        "Create crates/soldier_infra/src/store/trade_id_registry.rs with persistent registry logic.",
        "Wire registry into crates/soldier_infra/src/lib.rs.",
        "Append trade_id before applying TLSM or position updates.",
        "Implement insert-if-absent atomically (single transaction or unique constraint) to avoid double-apply on concurrency.",
        "Add counter trade_id_duplicates_total when a duplicate trade_id is ignored.",
        "Add unit tests in crates/soldier_infra/tests/test_trade_id_registry.rs for dedupe behavior, including a concurrent insert case."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_trade_id_registry"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_trade_id_registry output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
          "location": "CONTRACT.md Trade-ID Idempotency Registry (Ghost-Race Hardening)",
          "anchor": "AT-269"
        }
      ],
      "enforcing_contract_ats": [
        "AT-269",
        "AT-270"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::Unspecified"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "trade_id_duplicates_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_trade_id_registry.rs"
      ]
    },
    {
      "id": "S4-003",
      "priority": 70,
      "phase": 1,
      "slice": 4,
      "slice_ref": "Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry",
      "story_ref": "S4.4 Dispatch requires durable WAL barrier",
      "category": "durability",
      "description": "Block dispatch until WAL durability marker when configured.",
      "contract_refs": [
        "CONTRACT.md \u00a72.4.1 WAL Writer Isolation (Hot Loop Protection)",
        "CONTRACT.md \u00a72.4 Durable Intent Ledger",
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234",
        "Anchor-006",
        "VR-014"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md \u00a7Slice 4 \u2014 Durable WAL \\+ TLSM \\+ Trade\u2011ID Registry / S4.4 \u2014 Dispatch requires durable WAL barrier (when configured)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/src/lib.rs",
          "crates/soldier_infra/src/wal.rs",
          "crates/soldier_infra/tests/**"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_core/**",
          "crates/soldier_infra/src/deribit/**"
        ]
      },
      "acceptance": [
        "GIVEN the durability barrier config flag is enabled WHEN a caller awaits the durable-append barrier THEN the WAL returns only after the configured durability marker (fsync or equivalent) completes.",
        "GIVEN the durability barrier config flag is disabled WHEN a caller awaits the durable-append barrier THEN the WAL returns immediately after enqueue (no fsync wait).",
        "GIVEN the WAL enqueue queue is full or enqueue fails WHEN append is attempted THEN the WAL returns an error, increments wal_write_errors, and does not block the caller indefinitely."
      ],
      "steps": [
        "Extend the ledger to expose a durable-append barrier API and config flag.",
        "Ensure WAL enqueue failure increments wal_write_errors and returns error without blocking.",
        "Add unit tests in crates/soldier_infra/tests/test_dispatch_durability.rs for barrier behavior.",
        "Document configuration flag require_wal_fsync_before_dispatch in infra config.",
        "Add a helper to surface barrier wait time for observability."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_dispatch_durability"
      ],
      "evidence": [
        "cargo test -p soldier_infra --test test_dispatch_durability output"
      ],
      "dependencies": [
        "S4-000"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "RecordedBeforeDispatch is mandatory. DurableBeforeDispatch is required when the durability barrier flag is enabled.",
          "location": "CONTRACT.md \u00a72.4 Durable Intent Ledger",
          "anchor": "AT-935"
        }
      ],
      "enforcing_contract_ats": [
        "AT-935",
        "AT-906",
        "AT-233",
        "AT-234"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "EXEC_WAL_WRITE_FAILED"
        ]
      },
      "enforcement_point": "WAL",
      "failure_mode": [
        "backpressure"
      ],
      "observability": {
        "metrics": [
          {
            "name": "wal_durability_barrier_wait_ms",
            "type": "histogram",
            "unit": "ms",
            "labels": []
          },
          {
            "name": "wal_write_errors",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_dispatch_durability.rs"
      ]
    },
    {
      "id": "S5-000",
      "priority": 100,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.1 Liquidity Gate (book-walk WAP, reject sweep)",
      "category": "execution",
      "description": "Implement Liquidity Gate book-walk slippage checks and L2 staleness rejects for OPEN intents.",
      "contract_refs": [
        "CONTRACT.md \u00a71.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
        "CONTRACT.md Rejections due to missing/unparseable/stale L2 MUST use Rejected(LiquidityGateNoL2).",
        "CONTRACT.md AT-222",
        "CONTRACT.md AT-344",
        "CONTRACT.md AT-909",
        "CONTRACT.md AT-421",
        "VR-011"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.1 \u2014 Liquidity Gate (book-walk WAP, reject sweep)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/gate.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_liquidity_gate.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/**",
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN an L2 book where OrderQty implies slippage_bps > max_slippage_bps WHEN Liquidity Gate evaluates an OPEN intent THEN the intent is rejected with Rejected(ExpectedSlippageTooHigh) and no OrderIntent is emitted.",
        "GIVEN L2BookSnapshot is missing, unparseable, or older than l2_book_snapshot_max_age_ms WHEN Liquidity Gate evaluates an OPEN intent THEN it is rejected with Rejected(LiquidityGateNoL2) and dispatch count remains 0.",
        "GIVEN L2 is missing or stale WHEN evaluating intents THEN CANCEL-only proceeds and CLOSE/HEDGE order placement is rejected.",
        "GIVEN Liquidity Gate rejects WHEN evaluated THEN a LiquidityGateReject log entry includes WAP and slippage_bps."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/gate.rs with a Liquidity Gate evaluator that walks L2 depth and computes WAP and slippage_bps.",
        "Validate L2BookSnapshot freshness and structure; treat missing/unparseable/stale snapshots as LiquidityGateNoL2.",
        "Reject OPEN intents when slippage_bps exceeds max_slippage_bps with Rejected(ExpectedSlippageTooHigh).",
        "Emit a LiquidityGateReject log entry that includes WAP and slippage_bps on rejection.",
        "Export the Liquidity Gate from crates/soldier_core/src/execution/mod.rs for chokepoint integration.",
        "Add unit tests in crates/soldier_core/tests/test_liquidity_gate.rs for sweep rejection, no-L2 rejection reason, and cancel vs close/hedge behavior."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_liquidity_gate"
      ],
      "evidence": [
        "Assertions in test_liquidity_gate.rs for Rejected(ExpectedSlippageTooHigh) and Rejected(LiquidityGateNoL2)",
        "Captured LiquidityGateReject log entry with WAP and slippage_bps in test output",
        "cargo test -p soldier_core --test test_liquidity_gate output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Reject if slippage_bps > max_slippage_bps (default 10bps).",
          "location": "CONTRACT.md \u00a71.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
          "anchor": "CONTRACT.md \u00a71.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-222",
        "AT-344",
        "AT-909",
        "AT-421"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::ExpectedSlippageTooHigh",
          "RejectReason::LiquidityGateNoL2"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "expected_slippage_bps",
            "type": "histogram",
            "unit": "pct",
            "labels": []
          },
          {
            "name": "liquidity_gate_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_liquidity_gate.rs"
      ]
    },
    {
      "id": "S5-001",
      "priority": 90,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.2 Fee cache staleness (soft buffer / hard ReduceOnly latch)",
      "category": "risk",
      "description": "Apply fee model cache staleness rules with soft buffering and hard-stale RiskState::Degraded blocks.",
      "contract_refs": [
        "CONTRACT.md \u00a74.2 Fee-Aware Execution",
        "CONTRACT.md Fee Cache Staleness (Fail-Closed)",
        "CONTRACT.md AT-031",
        "CONTRACT.md AT-032",
        "CONTRACT.md AT-033",
        "CONTRACT.md AT-042",
        "CONTRACT.md AT-244",
        "CONTRACT.md AT-246",
        "VR-007"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.2 \u2014 Fee cache staleness (soft buffer / hard ReduceOnly latch)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk/fees.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/risk/state.rs",
          "crates/soldier_core/tests/test_fee_cache.rs",
          "crates/soldier_core/tests/test_fee_staleness.rs",
          "crates/soldier_infra/src/deribit/account_summary.rs",
          "crates/soldier_infra/src/deribit/mod.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN fee_model_cache_age_s is in the soft-stale window (fee_cache_soft_s < age <= fee_cache_hard_s) WHEN estimating fees THEN fee_rate_effective applies fee_stale_buffer (0.20).",
        "GIVEN fee_model_cache_age_s > fee_cache_hard_s WHEN evaluating an OPEN intent THEN RiskState::Degraded is set and the OPEN is rejected (fail-closed) with 0 dispatches.",
        "GIVEN fee_model_cached_at_ts_ms is missing or unparseable WHEN staleness is computed THEN it is treated as hard stale and OPEN intents are rejected (fail-closed).",
        "GIVEN fee tier changes WHEN the next polling cycle completes THEN NetEdge uses the updated fee tier within one cycle."
      ],
      "steps": [
        "Add crates/soldier_infra/src/deribit/account_summary.rs to parse /private/get_account_summary and store fee tier data with fee_model_cached_at_ts_ms in epoch ms.",
        "Poll the account summary every 60s and update fee_model_cache_age_s based on now_ms - fee_model_cached_at_ts_ms.",
        "Implement fee staleness logic in crates/soldier_core/src/risk/fees.rs to apply fee_stale_buffer in the soft-stale window.",
        "Treat hard-stale or missing fee_model_cached_at_ts_ms as RiskState::Degraded and expose the flag to Phase 1 dispatch authorization (OPEN blocked, CLOSE/HEDGE/CANCEL allowed).",
        "Add unit tests in crates/soldier_core/tests/test_fee_staleness.rs for soft buffer and hard stale behavior.",
        "Add unit tests in crates/soldier_core/tests/test_fee_cache.rs for missing timestamp handling, epoch-ms restart arithmetic, and fee tier update within one polling cycle."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_fee_cache",
        "cargo test -p soldier_core --test test_fee_staleness"
      ],
      "evidence": [
        "Test assertions showing soft-stale fee buffer and hard-stale OPEN rejection",
        "cargo test -p soldier_core --test test_fee_cache output",
        "cargo test -p soldier_core --test test_fee_staleness output"
      ],
      "dependencies": [
        "S5-000"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Hard stale (age > fee_cache_hard_s): set RiskState::Degraded.",
          "location": "CONTRACT.md \u00a74.2 Fee-Aware Execution",
          "anchor": "CONTRACT.md \u00a74.2 Fee-Aware Execution"
        }
      ],
      "enforcing_contract_ats": [
        "AT-031",
        "AT-032",
        "AT-033",
        "AT-042",
        "AT-244",
        "AT-246"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_FEE_MODEL_HARD_STALE",
          "REDUCEONLY_RISKSTATE_DEGRADED"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "fee_model_cache_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          },
          {
            "name": "fee_model_refresh_fail_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_fee_staleness.rs",
        "crates/soldier_core/tests/test_fee_cache.rs"
      ]
    },
    {
      "id": "S5-002",
      "priority": 80,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.3 NetEdge gate",
      "category": "execution",
      "description": "Reject OPEN intents when net edge after fees and slippage falls below min_edge_usd.",
      "contract_refs": [
        "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)",
        "CONTRACT.md net_edge_usd = gross_edge_usd - fee_usd - expected_slippage_usd",
        "CONTRACT.md AT-015",
        "CONTRACT.md AT-932",
        "Anchor-018",
        "VR-012",
        "VR-018",
        "VR-019",
        "VR-020"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.3 \u2014 NetEdge gate"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/gates.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_net_edge_gate.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/**",
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN net_edge_usd < min_edge_usd WHEN evaluating an OPEN intent THEN it is rejected with Rejected(NetEdgeTooLow) and no dispatch occurs.",
        "GIVEN fee_usd or expected_slippage_usd is missing/unparseable WHEN evaluating an OPEN intent THEN it is rejected with Rejected(NetEdgeInputMissing) and no dispatch occurs.",
        "GIVEN gross_edge_usd is missing/unparseable WHEN evaluating an OPEN intent THEN it is rejected (fail-closed) and no OrderIntent is emitted."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/gates.rs with a NetEdgeGate evaluator.",
        "Compute net_edge_usd from gross_edge_usd, fee_usd, and expected_slippage_usd.",
        "Reject OPEN intents when any NetEdge input is missing/unparseable with Rejected(NetEdgeInputMissing).",
        "Reject OPEN intents when net_edge_usd < min_edge_usd with Rejected(NetEdgeTooLow).",
        "Export NetEdgeGate from crates/soldier_core/src/execution/mod.rs for use in the dispatch chokepoint.",
        "Add unit tests in crates/soldier_core/tests/test_net_edge_gate.rs for low edge rejection, missing inputs, and fees exceeding gross edge."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_net_edge_gate"
      ],
      "evidence": [
        "Test assertions for Rejected(NetEdgeTooLow) and Rejected(NetEdgeInputMissing)",
        "cargo test -p soldier_core --test test_net_edge_gate output"
      ],
      "dependencies": [
        "S5-001"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "net_edge_usd = gross_edge_usd - fee_usd - expected_slippage_usd.",
          "location": "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)",
          "anchor": "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-015",
        "AT-932"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::NetEdgeTooLow",
          "RejectReason::NetEdgeInputMissing"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "net_edge_reject_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_net_edge_gate.rs"
      ]
    },
    {
      "id": "S5-003",
      "priority": 70,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.4 IOC limit pricer clamp (guarantee min edge at limit)",
      "category": "execution",
      "description": "Clamp IOC limit prices to guarantee min-edge bounds using the fee-aware pricer.",
      "contract_refs": [
        "CONTRACT.md \u00a71.4 Fee-Aware IOC Limit Pricer (No Market Orders)",
        "CONTRACT.md AT-223"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.4 \u2014 IOC limit pricer clamp (guarantee min edge at limit)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/pricer.rs",
          "crates/soldier_core/tests/test_pricer.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/**",
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN net_edge_usd < min_edge_usd WHEN the pricer evaluates an OPEN intent THEN it is rejected with Rejected(NetEdgeTooLow) and no dispatch occurs.",
        "GIVEN fair_price, fee_estimate_usd, min_edge_usd, qty, and side WHEN the pricer computes a limit THEN limit_price is clamped to max_price_for_min_edge and never crosses beyond the min-edge bound.",
        "GIVEN an IOC limit order fills WHEN execution occurs THEN no fill is worse than limit_price and realized edge at limit_price >= min_edge_usd."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/pricer.rs implementing the fee-aware IOC limit pricer.",
        "Compute net_edge_usd and reject OPEN intents when net_edge_usd < min_edge_usd.",
        "Calculate proposed_limit from fair_price +/- 0.5 * net_edge_per_unit and clamp to max_price_for_min_edge.",
        "Return limit_price for IOC dispatch without any market-order fallback.",
        "Export the pricer from crates/soldier_core/src/execution/mod.rs for chokepoint integration.",
        "Add unit tests in crates/soldier_core/tests/test_pricer.rs for clamped limits and min-edge enforcement."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_pricer"
      ],
      "evidence": [
        "Test assertions showing limit_price clamp and min-edge enforcement",
        "cargo test -p soldier_core --test test_pricer output"
      ],
      "dependencies": [
        "S5-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "Final limit clamped to guarantee min edge at the limit price.",
          "location": "CONTRACT.md \u00a71.4 Fee-Aware IOC Limit Pricer (No Market Orders)",
          "anchor": "CONTRACT.md \u00a71.4 Fee-Aware IOC Limit Pricer (No Market Orders)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-223"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::NetEdgeTooLow"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "pricer_limit_vs_fair_bps",
            "type": "histogram",
            "unit": "pct",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_pricer.rs"
      ]
    },
    {
      "id": "S5-004",
      "priority": 60,
      "phase": 1,
      "slice": 5,
      "slice_ref": "Slice 5 \u2014 Liquidity Gate \\+ Fee Model \\+ Net Edge \\+ Gate Ordering \\+ Pricer",
      "story_ref": "S5.5 Enforce single chokepoint build_order_intent() (gate ordering)",
      "category": "execution",
      "description": "Route all dispatch through build_order_intent() and enforce deterministic gate ordering at the chokepoint.",
      "contract_refs": [
        "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)",
        "CONTRACT.md \u00a71.3 Pre-Trade Liquidity Gate (Do Not Sweep the Book)",
        "CONTRACT.md RecordedBeforeDispatch",
        "CONTRACT.md CSP.5.2 Enforcement Rules"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 5 \u2014 Liquidity Gate + Fee Model + Net Edge + Gate Ordering + Pricer / S5.5 \u2014 Enforce single chokepoint build_order_intent() (gate ordering)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/build_order_intent.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_gate_ordering.rs",
          "crates/soldier_core/tests/test_phase1_dispatch_auth.rs"
        ],
        "create": [],
        "avoid": [
          "crates/soldier_infra/**",
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN build_order_intent is called for an OPEN intent WHEN gates run THEN the sequence is preflight -> quantize -> fee cache check -> Liquidity Gate -> Net Edge Gate -> pricer, and only after all pass does dispatch occur.",
        "GIVEN RiskState::Degraded WHEN an OPEN intent is evaluated at the chokepoint THEN it is rejected and dispatch count remains 0 while CLOSE/HEDGE/CANCEL remain allowed.",
        "GIVEN any dispatch attempt WHEN inspecting code paths THEN build_order_intent is the only constructor used for OrderIntent dispatch (no alternate bypass)."
      ],
      "steps": [
        "Create crates/soldier_core/src/execution/build_order_intent.rs to centralize intent construction and gating.",
        "Route all dispatch entry points through build_order_intent and return early on gate failures.",
        "Implement a deterministic gate sequence trace used by test_gate_ordering_call_log.",
        "Enforce Phase 1 dispatch authorization: if RiskState != Healthy, reject OPEN intents and allow CLOSE/HEDGE/CANCEL.",
        "Ensure intent recording occurs before any network dispatch (RecordedBeforeDispatch).",
        "Restrict dispatch helpers to pub(crate) and update module exports to prevent bypass.",
        "Add tests in crates/soldier_core/tests/test_gate_ordering.rs and test_phase1_dispatch_auth.rs."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_gate_ordering",
        "cargo test -p soldier_core --test test_phase1_dispatch_auth"
      ],
      "evidence": [
        "Gate sequence trace assertions showing ordered steps",
        "cargo test -p soldier_core --test test_gate_ordering output",
        "cargo test -p soldier_core --test test_phase1_dispatch_auth output"
      ],
      "dependencies": [
        "S5-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "This gate MUST run before any OrderIntent is eligible for dispatch.",
          "location": "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)",
          "anchor": "CONTRACT.md \u00a71.4.1 Net Edge Gate (Fees + Expected Slippage)"
        }
      ],
      "enforcing_contract_ats": [
        "AT-015"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_RISKSTATE_DEGRADED"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "gate_sequence_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_gate_ordering.rs",
        "crates/soldier_core/tests/test_phase1_dispatch_auth.rs"
      ]
    },
    {
      "id": "S6-000",
      "priority": 95,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "P1-A Single Dispatch Chokepoint Proof",
      "category": "hardening",
      "description": "Implement CI tests proving exactly one module/function may dispatch exchange orders with no bypass paths.",
      "contract_refs": [
        "RecordedBeforeDispatch",
        "AT-935",
        "Anchor-006",
        "VR-014",
        "1. Execution Architecture: The \"Atomic Group\" (Real-Time Repair)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_dispatch_chokepoint.rs",
          "docs/dispatch_chokepoint.md"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_dispatch_chokepoint_no_direct_exchange_client_usage runs WHEN exchange client is imported outside chokepoint module THEN test fails.",
        "GIVEN test_dispatch_visibility_is_restricted runs WHEN dispatch function is public beyond pub(crate) THEN test fails.",
        "GIVEN docs/dispatch_chokepoint.md exists WHEN reviewed THEN it names the exact module, function, and exchange client type."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_dispatch_chokepoint.rs with AST/grep checks for exchange client usage.",
        "Implement test_dispatch_chokepoint_no_direct_exchange_client_usage that fails if exchange client constructed outside chokepoint.",
        "Implement test_dispatch_visibility_is_restricted that fails if dispatch fn is not pub(crate).",
        "Create docs/dispatch_chokepoint.md documenting the chokepoint module, function, and normative statement.",
        "Run tests and verify they pass on compliant code."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_dispatch_chokepoint"
      ],
      "evidence": [
        "cargo test output showing test_dispatch_chokepoint_no_direct_exchange_client_usage PASS",
        "cargo test output showing test_dispatch_visibility_is_restricted PASS",
        "docs/dispatch_chokepoint.md exists with required content"
      ],
      "dependencies": [
        "S5-004"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-935"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_dispatch_chokepoint.rs"
      ]
    },
    {
      "id": "S6-001",
      "priority": 94,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "P1-B Determinism Snapshot Test",
      "category": "hardening",
      "description": "Implement CI test proving identical inputs produce identical intent bytes/hashes across runs and restarts.",
      "contract_refs": [
        "CSP.2.1 Stable Intent Identity",
        "1.1.1 Canonical Quantization (Pre-Hash & Pre-Dispatch)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_intent_determinism.rs",
          "evidence/phase1/determinism/intent_hashes.txt"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_intent_determinism_same_inputs_same_hash runs with fixed inputs and frozen clock WHEN executed twice THEN intent hash is identical.",
        "GIVEN test runs across process restart WHEN inputs are identical THEN hash is identical.",
        "GIVEN HashMap iteration order varies WHEN intent is built THEN hash is still identical (no map ordering dependency)."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_intent_determinism.rs.",
        "Implement test_intent_determinism_same_inputs_same_hash with clock injection.",
        "Use deterministic seed/inputs and assert exact byte equality or hash equality.",
        "Emit hash values to evidence/phase1/determinism/intent_hashes.txt.",
        "Run test twice and verify hashes match."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_intent_determinism"
      ],
      "evidence": [
        "cargo test output showing test_intent_determinism_same_inputs_same_hash PASS",
        "evidence/phase1/determinism/intent_hashes.txt showing identical hashes"
      ],
      "dependencies": [
        "S2-001"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-218",
        "AT-343",
        "AT-219",
        "AT-216"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_intent_determinism.rs"
      ]
    },
    {
      "id": "S6-002",
      "priority": 93,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "P1-C No Partial Side Effects on Rejection",
      "category": "hardening",
      "description": "Implement CI test proving rejected intents leave no persistent state changes except counters/logs.",
      "contract_refs": [
        "RecordedBeforeDispatch",
        "AT-201",
        "Anchor-006",
        "1.2 Atomic Group Executor"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_rejection_side_effects.rs",
          "evidence/phase1/no_side_effects/rejection_cases.md"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_rejected_intent_has_no_side_effects runs for missing config rejection THEN WAL unchanged, no orders, no position delta.",
        "GIVEN test runs for invalid instrument meta rejection THEN same assertions hold.",
        "GIVEN test runs for quantization failure rejection THEN same assertions hold.",
        "GIVEN evidence/phase1/no_side_effects/rejection_cases.md exists THEN it lists at least 3 rejection cases with CI links."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_rejection_side_effects.rs.",
        "Implement test_rejected_intent_has_no_side_effects with parameterized rejection cases.",
        "Assert: WAL unchanged, no open orders, no position deltas, no exposure increments.",
        "Create evidence/phase1/no_side_effects/rejection_cases.md documenting 3+ cases.",
        "Link CI logs in the evidence doc."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_rejection_side_effects"
      ],
      "evidence": [
        "cargo test output showing test_rejected_intent_has_no_side_effects PASS",
        "evidence/phase1/no_side_effects/rejection_cases.md with 3+ cases"
      ],
      "dependencies": [
        "S6-000"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-201"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_rejection_side_effects.rs"
      ]
    },
    {
      "id": "S6-003",
      "priority": 92,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "P1-D intent_id/run_id Propagation Contract",
      "category": "hardening",
      "description": "Implement CI test proving every intent-handling log/metric includes the same intent_id and run_id.",
      "contract_refs": [
        "0.Z.7.4 Observability Requirement"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_intent_id_propagation.rs",
          "evidence/phase1/traceability/sample_rejection_log.txt"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_intent_id_propagates_to_logs_and_metrics triggers a rejected intent WHEN logs are captured THEN every log line includes identical intent_id.",
        "GIVEN metrics are emitted during intent handling WHEN inspected THEN they include intent_id label.",
        "GIVEN evidence/phase1/traceability/sample_rejection_log.txt exists THEN it shows consistent intent_id across all log lines."
      ],
      "steps": [
        "Create crates/soldier_core/tests/test_intent_id_propagation.rs.",
        "Implement test_intent_id_propagates_to_logs_and_metrics with log capture.",
        "Trigger a rejection and collect all logs/metrics from the intent span.",
        "Assert all entries include the same intent_id.",
        "Emit sample log to evidence/phase1/traceability/sample_rejection_log.txt."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_intent_id_propagation"
      ],
      "evidence": [
        "cargo test output showing test_intent_id_propagates_to_logs_and_metrics PASS",
        "evidence/phase1/traceability/sample_rejection_log.txt"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-024",
        "AT-025",
        "AT-026"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "intent_id_propagation_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "result"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_intent_id_propagation.rs"
      ]
    },
    {
      "id": "S6-004",
      "priority": 91,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "P1-E Gate Ordering Constraints",
      "category": "hardening",
      "description": "Implement CI test and doc proving gate ordering invariants: reject before persist, WAL before dispatch.",
      "contract_refs": [
        "CONTRACT.md RecordedBeforeDispatch",
        "CONTRACT.md CSP.5.2 Enforcement Rules",
        "Anchor-006",
        "VR-014"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_gate_ordering.rs",
          "docs/intent_gate_invariants.md"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_gate_ordering_constraints runs WHEN a side effect occurs before final accept THEN test fails.",
        "GIVEN WAL commit is attempted after dispatch WHEN test runs THEN test fails.",
        "GIVEN docs/intent_gate_invariants.md exists THEN it states the 3 normative ordering constraints."
      ],
      "steps": [
        "Extend or create crates/soldier_core/tests/test_gate_ordering.rs.",
        "Implement test_gate_ordering_constraints with instrumented gate/side-effect events.",
        "Assert: reject gates before persist, WAL before dispatch, no side effects before accept.",
        "Create docs/intent_gate_invariants.md with normative statements.",
        "Run test and verify pass."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_gate_ordering"
      ],
      "evidence": [
        "cargo test output showing test_gate_ordering_constraints PASS",
        "docs/intent_gate_invariants.md with 3 normative statements"
      ],
      "dependencies": [
        "S5-004"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-010",
        "AT-1055",
        "AT-338"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_gate_ordering.rs"
      ]
    },
    {
      "id": "S6-005",
      "priority": 90,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "P1-F Fail-Closed Defaults for Missing Config",
      "category": "hardening",
      "description": "Implement CI test proving missing critical config causes fail-closed rejection with enumerated reason code.",
      "contract_refs": [
        "Appendix A",
        "Appendix A: Configuration Defaults (Safety-Critical Thresholds)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/tests/test_missing_config.rs",
          "docs/critical_config_keys.md",
          "evidence/phase1/config_fail_closed/missing_keys_matrix.json"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_missing_config_fails_closed runs for each critical key WHEN key is removed THEN intent rejected.",
        "GIVEN rejection occurs THEN no persistent side effects (WAL, orders, positions).",
        "GIVEN rejection occurs THEN reject reason is enumerated (not free text).",
        "GIVEN evidence/phase1/config_fail_closed/missing_keys_matrix.json exists THEN it shows PASS/FAIL + reason code per key."
      ],
      "steps": [
        "Create docs/critical_config_keys.md listing Phase-1 critical config keys.",
        "Create crates/soldier_core/tests/test_missing_config.rs.",
        "Implement test_missing_config_fails_closed parameterized over critical keys.",
        "Assert rejection, no side effects, enumerated reason code.",
        "Emit evidence/phase1/config_fail_closed/missing_keys_matrix.json from test."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_missing_config"
      ],
      "evidence": [
        "cargo test output showing test_missing_config_fails_closed PASS",
        "docs/critical_config_keys.md",
        "evidence/phase1/config_fail_closed/missing_keys_matrix.json"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-110"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "CONFIG_MISSING"
        ]
      },
      "enforcement_point": "",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_missing_config.rs"
      ]
    },
    {
      "id": "S6-006",
      "priority": 89,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "P1-G Minimal Crash-Mid-Intent Proof",
      "category": "hardening",
      "description": "Implement CI test or drill proving crash mid-intent before dispatch causes no duplicate dispatch on restart.",
      "contract_refs": [
        "AT-935",
        "AT-233",
        "2.4 \u2014 WAL / intent ledger (RecordedBeforeDispatch)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_infra/tests/test_crash_mid_intent.rs",
          "evidence/phase1/crash_mid_intent/drill.md"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN test_crash_mid_intent_no_duplicate_dispatch runs WHEN process crashes before dispatch THEN restart produces no dispatch.",
        "GIVEN crash occurs mid-intent THEN no ghost state or unsafe opens on restart.",
        "IF AUTO test not feasible THEN evidence/phase1/crash_mid_intent/drill.md documents manual drill with proof logs."
      ],
      "steps": [
        "Create crates/soldier_infra/tests/test_crash_mid_intent.rs (preferred AUTO).",
        "Implement test_crash_mid_intent_no_duplicate_dispatch simulating crash before dispatch.",
        "Assert: no dispatch on restart, no side effects beyond counters/logs.",
        "If AUTO not feasible, document manual drill in evidence/phase1/crash_mid_intent/drill.md.",
        "Include trigger, restart steps, and proof logs in drill doc."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_infra --test test_crash_mid_intent"
      ],
      "evidence": [
        "OR evidence/phase1/crash_mid_intent/drill.md with recorded proof",
        "cargo test output showing test_crash_mid_intent_no_duplicate_dispatch PASS"
      ],
      "dependencies": [
        "S4-000",
        "S4-003"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-233",
        "AT-935"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "WAL",
      "failure_mode": [],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_crash_mid_intent.rs"
      ]
    },
    {
      "id": "S6-007",
      "priority": 88,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "Inventory Skew Gate",
      "category": "hardening",
      "description": "Implement Inventory Skew Gate (\u00a71.4.2) that biases execution against compounding inventory and requires higher edge/worse prices for risk-increasing trades near delta limits.",
      "contract_refs": [
        "\u00a71.4.2 Inventory Skew Gate (Execution Bias vs Current Exposure)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk/inventory_skew.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/tests/test_inventory_skew.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN current_delta \u2248 0.9 * delta_limit WHEN BUY intent evaluated THEN rejected (risk-increasing near limit).",
        "GIVEN current_delta \u2248 0.9 * delta_limit WHEN SELL intent evaluated THEN allowed (risk-reducing).",
        "GIVEN delta_limit missing WHEN OPEN intent evaluated THEN rejected with InventorySkewDeltaLimitMissing.",
        "GIVEN inventory_bias=1.0 for BUY WHEN limit price computed THEN shifts 3 ticks away from touch.",
        "GIVEN pending_delta reserved WHEN Inventory Skew evaluates THEN uses current + pending exposure."
      ],
      "steps": [
        "Create crates/soldier_core/src/risk/inventory_skew.rs with gate logic.",
        "Implement inventory_bias computation: clamp(current_delta / delta_limit, -1, +1).",
        "Implement min_edge_usd adjustment for risk-increasing trades.",
        "Implement limit_price bias_ticks shift (3 tick max penalty).",
        "Add rejection with InventorySkewDeltaLimitMissing when delta_limit missing.",
        "Create crates/soldier_core/tests/test_inventory_skew.rs with acceptance tests.",
        "Add test for AT-224 (BUY rejected near limit, SELL allowed).",
        "Add test for AT-043, AT-922 (delta_limit missing rejection).",
        "Add test for AT-030 (3 tick shift at inventory_bias=1.0).",
        "Add test for AT-934 (current + pending exposure check)."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_inventory_skew"
      ],
      "evidence": [
        "cargo test output showing test_inventory_skew PASS",
        "crates/soldier_core/src/risk/inventory_skew.rs"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-224",
        "AT-043",
        "AT-922",
        "AT-030",
        "AT-934"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "InventorySkewDeltaLimitMissing"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [
        "missing",
        "parse_error"
      ],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_inventory_skew.rs"
      ]
    },
    {
      "id": "S6-008",
      "priority": 87,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "PendingExposure Reservation",
      "category": "hardening",
      "description": "Implement PendingExposure Reservation (\u00a71.4.2.1) to prevent concurrent signals from observing same 'free delta' and over-allocating risk budget.",
      "contract_refs": [
        "\u00a71.4.2.1 PendingExposure Reservation (Anti Over\u2011Fill)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/risk/pending_exposure.rs",
          "crates/soldier_core/tests/test_pending_exposure.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN 5 concurrent opens with identical current_delta=0 WHEN PendingExposure reserve runs THEN only subset fitting budget reserves.",
        "GIVEN reservation would breach budget WHEN reserve() attempted THEN rejected with PendingExposureBudgetExceeded and no dispatch.",
        "GIVEN terminal outcome (Filled/Rejected/Canceled) WHEN triggered THEN reservation released."
      ],
      "steps": [
        "Create crates/soldier_core/src/risk/pending_exposure.rs with reservation logic.",
        "Implement pending_delta tracking per instrument + global.",
        "Implement reserve(delta_impact_est) with budget breach check.",
        "Implement release on terminal TLSM transitions.",
        "Add rejection with PendingExposureBudgetExceeded when budget breached.",
        "Create crates/soldier_core/tests/test_pending_exposure.rs with acceptance tests.",
        "Add test for AT-225 (5 concurrent opens, subset reserves).",
        "Add test for AT-910 (budget breach rejection)."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_pending_exposure"
      ],
      "evidence": [
        "cargo test output showing test_pending_exposure PASS",
        "crates/soldier_core/src/risk/pending_exposure.rs"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-225",
        "AT-910"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "PendingExposureBudgetExceeded"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [
        "missing",
        "stale"
      ],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_pending_exposure.rs"
      ]
    },
    {
      "id": "S6-009",
      "priority": 86,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "Global Exposure Budget",
      "category": "hardening",
      "description": "Implement Global Exposure Budget (\u00a71.4.2.2) to prevent 'safe per-instrument' trades from stacking into unsafe portfolio exposure using correlation-aware aggregation.",
      "contract_refs": [
        "\u00a71.4.2.2 Global Exposure Budget (Cross\u2011Instrument, Correlation\u2011Aware)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk/exposure_budget.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/tests/test_exposure_budget.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN BTC and ETH both near limits WHEN new BTC trade passes local delta gate THEN rejected if portfolio budget breaches after correlation.",
        "GIVEN portfolio exposure would breach WHEN Global Budget evaluates OPEN THEN rejected with GlobalExposureBudgetExceeded and no dispatch.",
        "GIVEN pending_delta reserved near limit WHEN Global Budget evaluates THEN uses current + pending exposure."
      ],
      "steps": [
        "Create crates/soldier_core/src/risk/exposure_budget.rs with portfolio logic.",
        "Implement per-instrument delta_usd tracking.",
        "Implement portfolio aggregation with correlation buckets (BTC/ETH=0.8, BTC/alts=0.6, ETH/alts=0.6).",
        "Implement portfolio breach check using current + pending exposure.",
        "Add rejection with GlobalExposureBudgetExceeded when portfolio breaches.",
        "Create crates/soldier_core/tests/test_exposure_budget.rs with acceptance tests.",
        "Add test for AT-226 (BTC+ETH correlation breach).",
        "Add test for AT-911 (portfolio breach rejection).",
        "Add test for AT-929 (current + pending exposure check)."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_exposure_budget"
      ],
      "evidence": [
        "cargo test output showing test_exposure_budget PASS",
        "crates/soldier_core/src/risk/exposure_budget.rs"
      ],
      "dependencies": [
        "S6-008"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-226",
        "AT-911",
        "AT-929"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "GlobalExposureBudgetExceeded"
        ]
      },
      "enforcement_point": "DispatcherChokepoint",
      "failure_mode": [
        "missing",
        "stale"
      ],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_exposure_budget.rs"
      ]
    },
    {
      "id": "S6-010",
      "priority": 85,
      "phase": 1,
      "slice": 6,
      "slice_ref": "Slice 6 \u2014 Phase 1 Hardening Gates",
      "story_ref": "Margin Headroom Gate",
      "category": "hardening",
      "description": "Implement Margin Headroom Gate (\u00a71.4.3) to prevent margin liquidation via mm_util thresholds that reject opens and force ReduceOnly/Kill modes.",
      "contract_refs": [
        "\u00a71.4.3 Margin Headroom Gate (Liquidation Shield)"
      ],
      "plan_refs": [
        "Phase 1 \u2014 Foundation (Panic\u2011Free Deterministic Intents)"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk/margin_gate.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/tests/test_margin_gate.rs",
          "crates/soldier_infra/src/deribit/account_summary.rs"
        ],
        "create": [],
        "avoid": [
          "plans/**"
        ]
      },
      "acceptance": [
        "GIVEN mm_util >= mm_util_reject_opens WHEN OPEN evaluated THEN rejected with MarginHeadroomRejectOpens.",
        "GIVEN mm_util >= mm_util_reduceonly WHEN PolicyGuard computes TradingMode THEN TradingMode=ReduceOnly.",
        "GIVEN mm_util >= mm_util_kill WHEN PolicyGuard computes TradingMode THEN TradingMode=Kill and emergency flatten eligible.",
        "GIVEN equity=100k, maintenance_margin=72k WHEN Margin Gate evaluates OPEN THEN OPEN rejected.",
        "GIVEN equity=100k, maintenance_margin=90k WHEN PolicyGuard computes THEN TradingMode=ReduceOnly."
      ],
      "steps": [
        "Create crates/soldier_core/src/risk/margin_gate.rs with mm_util logic.",
        "Implement mm_util = maintenance_margin / max(equity, epsilon).",
        "Implement gate rejection at mm_util_reject_opens with MarginHeadroomRejectOpens.",
        "Extend PolicyGuard to force ReduceOnly at mm_util_reduceonly.",
        "Extend PolicyGuard to force Kill at mm_util_kill.",
        "Create crates/soldier_infra/src/deribit/account_summary.rs stub for /private/get_account_summary.",
        "Create crates/soldier_core/tests/test_margin_gate.rs with acceptance tests.",
        "Add test for AT-227, AT-912 (OPEN rejected at mm_util_reject_opens).",
        "Add test for AT-228, AT-207 (ReduceOnly at mm_util_reduceonly).",
        "Add test for AT-208 (Kill at mm_util_kill).",
        "Add test for AT-206 (gate independent of TradingMode)."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_margin_gate"
      ],
      "evidence": [
        "cargo test output showing test_margin_gate PASS",
        "crates/soldier_core/src/risk/margin_gate.rs"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "high",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-227",
        "AT-912",
        "AT-228",
        "AT-206",
        "AT-207",
        "AT-208"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "MarginHeadroomRejectOpens"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [
        "missing",
        "stale"
      ],
      "observability": {
        "metrics": [],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_margin_gate.rs"
      ]
    },
    {
      "id": "S7-000",
      "priority": 88,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
      "story_ref": "S7.1 Group state machine + first-fail invariant",
      "category": "execution",
      "description": "Implement atomic group state machine with first-fail invariant to prevent marking Complete until safe.",
      "contract_refs": [
        "CONTRACT.md \u00a73 Atomic Group Execution",
        "AT-116"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 7 \u2014 Atomic Group Executor + Emergency Close / S7.1"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/atomic_group_executor.rs",
          "crates/soldier_core/src/execution/group.rs",
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/tests/test_atomic_group.rs",
          "docs/plans/2026-02-14-s7-000-atomic-group-design.md"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN atomic group state WHEN evaluated THEN cannot mark Complete until safe.",
        "GIVEN first observed failure WHEN processing group THEN seeds MixedFailed and is not overwritten by later async updates.",
        "GIVEN MixedFailed state WHEN evaluating THEN blocks opens until neutral."
      ],
      "steps": [
        "Create group.rs and atomic_group_executor.rs modules.",
        "Implement group state machine transitions.",
        "Ensure first failure seeds MixedFailed deterministically.",
        "Add test_atomic_group_mixed_failed_then_flattened.",
        "Add test_mixed_failed_blocks_opens_until_neutral (AT-116).",
        "Add counter atomic_group_state_total{state}."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_atomic_group"
      ],
      "evidence": [
        "ENABLE_ATOMIC_GROUPS config flag documented",
        "cargo test output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "high",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md \u00a71.1.1 Atomic Group Executor - First-Fail Invariant",
          "location": "CONTRACT.md \u00a71.1.1",
          "anchor": "AT-098"
        },
        {
          "quote": "CONTRACT.md \u00a71.1.1 Atomic Group Executor - State Machine",
          "location": "CONTRACT.md \u00a71.1.1",
          "anchor": "AT-099"
        }
      ],
      "enforcing_contract_ats": [
        "AT-116"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_ATOMIC_NAKED"
        ]
      },
      "enforcement_point": "AtomicGroupExecutor",
      "failure_mode": [
        "stall"
      ],
      "observability": {
        "metrics": [
          {
            "name": "atomic_group_state_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "state"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_atomic_group.rs"
      ]
    },
    {
      "id": "S7-001",
      "priority": 87,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
      "story_ref": "S7.2 Bounded rescue (\u22642) and no chase loop",
      "category": "execution",
      "description": "Limit rescue attempts to max 2 IOC tries before fallback to flatten.",
      "contract_refs": [
        "CONTRACT.md \u00a73 Atomic Group Execution",
        "AT-117"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 7 / S7.2"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/atomic_group_executor.rs",
          "crates/soldier_core/tests/test_atomic_group.rs"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN rescue attempts WHEN processing atomic group THEN max 2 rescue IOC attempts.",
        "GIVEN 2 rescue failures WHEN fallback triggered THEN flatten path executes.",
        "GIVEN rescue exhausted WHEN fallback triggered THEN no chase loop occurs."
      ],
      "steps": [
        "Add rescue attempt counter to atomic_group_executor.rs.",
        "Enforce max 2 rescue IOC attempts.",
        "Trigger flatten after 2nd rescue failure.",
        "Add test_atomic_rescue_attempts_limited_to_two (AT-117).",
        "Add histogram atomic_rescue_attempts."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_atomic_group"
      ],
      "evidence": [
        "cargo test output"
      ],
      "dependencies": [
        "S7-000"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md \u00a71.1.2 Partial Fill Tracking",
          "location": "CONTRACT.md \u00a71.1.2",
          "anchor": "AT-117"
        }
      ],
      "enforcing_contract_ats": [
        "AT-117"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::MaxRetriesExceeded"
        ]
      },
      "enforcement_point": "AtomicGroupExecutor",
      "failure_mode": [
        "stall"
      ],
      "observability": {
        "metrics": [
          {
            "name": "atomic_rescue_attempts",
            "type": "histogram",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_atomic_group.rs"
      ]
    },
    {
      "id": "S7-002",
      "priority": 86,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
      "story_ref": "S7.3 Deterministic emergency close + hedge fallback",
      "category": "execution",
      "description": "Implement emergency close algorithm: 3 tries IOC close, then reduce-only delta hedge; logs AtomicNakedEvent; TradingMode is ReduceOnly during exposure.",
      "contract_refs": [
        "CONTRACT.md \u00a73.1 Emergency Close",
        "AT-338",
        "AT-339",
        "AT-340",
        "AT-346",
        "AT-347",
        "AT-013"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 7 / S7.3"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/emergency_close.rs",
          "crates/soldier_core/tests/test_emergency_close.rs"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN emergency close triggered WHEN processing THEN 3 IOC close attempts with doubling buffer (5\u219210\u219220 ticks).",
        "GIVEN 3 close failures WHEN fallback triggered THEN reduce-only delta hedge executes.",
        "GIVEN exposure remains WHEN processing THEN logs AtomicNakedEvent and TradingMode is ReduceOnly.",
        "GIVEN emergency close WHEN evaluating gates THEN bypasses liquidity and net_edge gates."
      ],
      "steps": [
        "Create emergency_close.rs module.",
        "Implement 3-try close with doubling buffer (close_buffer_ticks: 5\u219210\u219220).",
        "Add reduce-only delta hedge fallback.",
        "Log AtomicNakedEvent on naked exposure.",
        "Bypass liquidity/net_edge gates for emergency close.",
        "Add test_emergency_close_fallback_hedge_after_retries.",
        "Add test_emergency_close_bypasses_liquidity_gate.",
        "Add test_emergency_close_bypasses_net_edge_gate.",
        "Add Kill-tier containment tests (AT-338/339/340/346/347/013).",
        "Add histogram time_to_delta_neutral_ms, counter atomic_naked_events_total."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_emergency_close"
      ],
      "evidence": [
        "cargo test output"
      ],
      "dependencies": [
        "S7-000"
      ],
      "est_size": "S",
      "risk": "high",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md \u00a71.1.3 Emergency Close - Naked Inventory Reduction",
          "location": "CONTRACT.md \u00a71.1.3",
          "anchor": "AT-338"
        },
        {
          "quote": "CONTRACT.md \u00a71.1.3 Emergency Close - REDUCEONLY_ATOMIC_NAKED mode",
          "location": "CONTRACT.md \u00a71.1.3",
          "anchor": "AT-339"
        }
      ],
      "enforcing_contract_ats": [
        "AT-338",
        "AT-339",
        "AT-340",
        "AT-346",
        "AT-347",
        "AT-013"
      ],
      "reason_codes": {
        "type": "ModeReasonCode",
        "values": [
          "REDUCEONLY_ATOMIC_NAKED"
        ]
      },
      "enforcement_point": "AtomicGroupExecutor",
      "failure_mode": [
        "stall"
      ],
      "observability": {
        "metrics": [
          {
            "name": "time_to_delta_neutral_ms",
            "type": "histogram",
            "unit": "ms",
            "labels": []
          },
          {
            "name": "atomic_naked_events_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_emergency_close.rs"
      ]
    },
    {
      "id": "S7-003",
      "priority": 85,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
      "story_ref": "S7.4 Sequencer ordering rules",
      "category": "execution",
      "description": "Implement sequencer with close\u2192confirm\u2192hedge ordering; repair flattens before hedge; never increase exposure when RiskState != Healthy.",
      "contract_refs": [
        "CONTRACT.md \u00a73 Sequencer"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 7 / S7.4"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/execution/mod.rs",
          "crates/soldier_core/src/execution/sequencer.rs",
          "crates/soldier_core/tests/test_sequencer.rs"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN sequencer ordering WHEN processing THEN close\u2192confirm\u2192hedge order enforced.",
        "GIVEN repair path WHEN processing THEN flatten filled legs first via emergency_close_algorithm; hedge only after flatten retries fail.",
        "GIVEN RiskState != Healthy WHEN evaluating THEN never increase exposure."
      ],
      "steps": [
        "Create sequencer.rs module.",
        "Implement close\u2192confirm\u2192hedge ordering.",
        "Add repair path: flatten first, hedge only after retries fail.",
        "Block exposure increase when RiskState != Healthy.",
        "Add test_sequencer_close_then_hedge_ordering.",
        "Add test_sequencer_blocks_exposure_increase_when_riskstate_not_healthy.",
        "Add test_sequencer_repair_flattens_before_hedge.",
        "Add counter sequencer_order_violation_total."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_sequencer"
      ],
      "evidence": [
        "cargo test output"
      ],
      "dependencies": [
        "S7-002"
      ],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md \u00a71.1.4 Order Sequencer - Atomic Group Submit",
          "location": "CONTRACT.md \u00a71.1.4",
          "anchor": "AT-125"
        },
        {
          "quote": "CONTRACT.md \u00a71.1.4 Order Sequencer - Partial Fill Handling",
          "location": "CONTRACT.md \u00a71.1.4",
          "anchor": "AT-126"
        }
      ],
      "enforcing_contract_ats": [
        "AT-125",
        "AT-126",
        "AT-127",
        "AT-128"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::RiskStateNotHealthy"
        ]
      },
      "enforcement_point": "AtomicGroupExecutor",
      "failure_mode": [
        "stall"
      ],
      "observability": {
        "metrics": [
          {
            "name": "sequencer_order_violation_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_sequencer.rs"
      ]
    },
    {
      "id": "S7-004",
      "priority": 84,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
      "story_ref": "S7.5 Churn breaker",
      "category": "risk",
      "description": "Implement churn breaker: >2 flattens/5m => 15m blacklist blocks opens for that key.",
      "contract_refs": [
        "CONTRACT.md \u00a71.2.2 Atomic Churn Circuit Breaker (Flatten Storm Guard)"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 7 / S7.5"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk/churn_breaker.rs",
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/tests/test_churn_breaker.rs"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN >2 flattens in 5m window WHEN evaluating THEN 15m blacklist blocks opens for that key.",
        "GIVEN blacklist active WHEN evaluating opens THEN opens are blocked.",
        "GIVEN churn breaker inactive WHEN evaluating THEN opens are allowed."
      ],
      "steps": [
        "Create churn_breaker.rs module.",
        "Track flatten events per key with 5m window.",
        "Apply 15m blacklist on >2 flattens/5m.",
        "Block opens for blacklisted keys.",
        "Add test_churn_breaker_blacklists_after_three.",
        "Add counter churn_breaker_trip_total."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_churn_breaker"
      ],
      "evidence": [
        "cargo test output"
      ],
      "dependencies": [
        "S7-002"
      ],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md \u00a71.2.1 Churn Breaker - Flip-Flop Backoff",
          "location": "CONTRACT.md \u00a71.2.1",
          "anchor": "AT-341"
        },
        {
          "quote": "CONTRACT.md \u00a71.2.1 Churn Breaker - RejectReason::ChurnBreakerActive",
          "location": "CONTRACT.md \u00a71.2.1",
          "anchor": "AT-342"
        }
      ],
      "enforcing_contract_ats": [
        "AT-341",
        "AT-342",
        "AT-343",
        "AT-344"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::ChurnBreakerActive"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "churn_breaker_trip_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_churn_breaker.rs"
      ]
    },
    {
      "id": "S7-005",
      "priority": 83,
      "phase": 2,
      "slice": 7,
      "slice_ref": "Slice 7 \u2014 Atomic Group Executor + Emergency Close + Sequencer + Churn Breaker",
      "story_ref": "S7.6 Self-Impact Feedback Loop Guard (Echo Chamber Breaker)",
      "category": "risk",
      "description": "Implement self-impact guard: stale/missing trade feed blocks opens; self_fraction/notional trip conditions reject with cooldown.",
      "contract_refs": [
        "CONTRACT.md \u00a71.2.3 Self-Impact Feedback Loop Guard",
        "AT-953",
        "AT-955",
        "AT-956",
        "AT-957"
      ],
      "plan_refs": [
        "IMPLEMENTATION_PLAN.md Slice 7 / S7.6"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/risk/self_impact_guard.rs",
          "crates/soldier_core/tests/test_self_impact.rs"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN public trade feed stale/missing WHEN evaluating THEN set RiskState::Degraded, set WS_TRADES_GAP_RECONCILE_REQUIRED latch, block opens until reconcile clears.",
        "GIVEN feed fresh and self_fraction/notional trip WHEN evaluating open in same direction THEN reject with FeedbackLoopGuardActive and apply cooldown.",
        "GIVEN self-impact below threshold WHEN evaluating THEN allow open."
      ],
      "steps": [
        "Create self_impact_guard.rs module.",
        "Check trade feed freshness; if stale/missing: set Degraded + latch.",
        "Compute self_fraction and self_notional when feed fresh.",
        "Apply trip conditions and reject with cooldown.",
        "Add test_self_impact_stale_feed_sets_latch (AT-953).",
        "Add test_self_impact_fraction_trip_rejects (AT-955).",
        "Add test_self_impact_notional_trip_rejects (AT-956).",
        "Add test_self_impact_below_threshold_allows (AT-957).",
        "Add counter self_impact_trip_total."
      ],
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --test test_self_impact"
      ],
      "evidence": [
        "cargo test output"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "med",
      "needs_human_decision": false,
      "passes": true,
      "contract_must_evidence": [
        {
          "quote": "CONTRACT.md \u00a71.2.3 Self-Impact Feedback Loop Guard - Trade Feed Freshness",
          "location": "CONTRACT.md \u00a71.2.3",
          "anchor": "AT-953"
        },
        {
          "quote": "CONTRACT.md \u00a71.2.3 Self-Impact Feedback Loop Guard - Self Fraction Trip",
          "location": "CONTRACT.md \u00a71.2.3",
          "anchor": "AT-955"
        },
        {
          "quote": "CONTRACT.md \u00a71.2.3 Self-Impact Feedback Loop Guard - Self Notional Trip",
          "location": "CONTRACT.md \u00a71.2.3",
          "anchor": "AT-956"
        }
      ],
      "enforcing_contract_ats": [
        "AT-953",
        "AT-955",
        "AT-956",
        "AT-957"
      ],
      "reason_codes": {
        "type": "RejectReason",
        "values": [
          "RejectReason::FeedbackLoopGuardActive"
        ]
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "self_impact_trip_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_self_impact.rs"
      ]
    },
    {
      "id": "S8-000",
      "priority": 800,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.1 \u2014 PolicyGuard precedence + staleness handling",
      "category": "policy",
      "description": "Implement PolicyGuard Critical Input Freshness (\u00a72.2.1.1), full precedence ladder, 27-state axis resolver, corroboration inputs, and Non-Active OPEN cancellation. Includes PL-3 axis resolver tests.",
      "contract_refs": [
        "\u00a72.2.1.1 Critical Input Freshness",
        "\u00a72.2.3 TradingMode Computation",
        "\u00a72.2.3.3 TradingMode Resolution",
        "\u00a72.2.3.4.1 Non\u2011Active OPEN Cancellation",
        "AT-001",
        "AT-112",
        "AT-1048",
        "AT-1050",
        "AT-1051",
        "AT-1052",
        "AT-1053",
        "AT-1054",
        "AT-1055",
        "AT-1065",
        "AT-1066",
        "AT-1067",
        "AT-1068",
        "AT-1069"
      ],
      "plan_refs": [
        "S8.1",
        "PL-3"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/src/policy/guard.rs",
          "crates/soldier_core/tests/test_policy_guard.rs",
          "crates/soldier_core/tests/test_policy_freshness.rs",
          "crates/soldier_core/tests/test_order_cancel.rs",
          "crates/soldier_core/tests/test_profile_isolation.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN mm_util or disk_used_pct missing/stale WHEN evaluated THEN TradingMode=ReduceOnly with REDUCEONLY_INPUT_MISSING_OR_STALE",
        "GIVEN policy_age_sec == 300 WHEN evaluated THEN does NOT trip (boundary)",
        "GIVEN policy_age_sec == 301 WHEN evaluated THEN trips ReduceOnly",
        "GIVEN all 27 axis combinations WHEN evaluated THEN deterministic TradingMode outputs (AT-1048)",
        "GIVEN TradingMode != Active WHEN evaluated THEN cancel all OPEN orders with reduce_only != true",
        "GIVEN enforced_profile == CSP WHEN GOP inputs present THEN treat as nonexistent (AT-991, AT-992)"
      ],
      "steps": [
        "Implement PolicyGuard.get_effective_mode() with input snapshot coherency",
        "Add critical inputs: mm_util, disk_used_pct, rate_limit_session_kill_active, watchdog_last_heartbeat_ts_ms",
        "Add corroboration inputs: loop_tick_last_ts_ms, disk_used_pct_secondary, 10028_count_5m",
        "Implement policy_age_sec computation: floor((now_ms - python_policy_generated_ts_ms)/1000)",
        "Implement 27-state axis resolver (MarketIntegrityAxis, CapitalRiskAxis, SystemIntegrityAxis)",
        "Implement Non-Active OPEN cancellation with cancel_open_batch_max / cancel_open_budget_ms",
        "Implement profile isolation: CSP ignores GOP-only inputs",
        "Add all required tests (14 ATs)",
        "Add observability: policy_age_sec gauge, policy_stale_reduceonly_total counter"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_policy_guard"
      ],
      "evidence": [
        "crates/soldier_core/tests/test_policy_guard.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-001",
        "AT-112",
        "AT-1048",
        "AT-1050",
        "AT-1051",
        "AT-1052",
        "AT-1053",
        "AT-1054",
        "AT-1055",
        "AT-1065",
        "AT-1066",
        "AT-1067",
        "AT-1068",
        "AT-1069"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "policy_age_sec",
            "type": "gauge",
            "unit": "s",
            "labels": []
          },
          {
            "name": "policy_stale_reduceonly_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_policy_guard.rs"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "high",
      "needs_human_decision": false
    },
    {
      "id": "S8-001",
      "priority": 801,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.2 \u2014 Runtime F1 gate (HARD): artifacts/F1_CERT.json",
      "category": "policy",
      "description": "Implement runtime F1 certification gate: missing/stale/FAIL => ReduceOnly. Binding enforcement on contract_version, build_id, runtime_config_hash. Includes PL-2 canonical runtime_config_hash.",
      "contract_refs": [
        "\u00a72.2.1 Runtime F1 Certification Gate",
        "AT-012",
        "AT-020",
        "AT-021"
      ],
      "plan_refs": [
        "S8.2",
        "PL-2"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/tests/fixtures/F1_CERT.json",
          "crates/soldier_core/src/policy/guard.rs",
          "crates/soldier_core/tests/test_f1_gate.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN F1_CERT missing/unparseable WHEN evaluated THEN TradingMode=ReduceOnly",
        "GIVEN F1_CERT.contract_version != runtime WHEN evaluated THEN TradingMode=ReduceOnly (AT-020)",
        "GIVEN F1_CERT.build_id != runtime WHEN evaluated THEN TradingMode=ReduceOnly",
        "GIVEN F1_CERT.runtime_config_hash != runtime WHEN evaluated THEN TradingMode=ReduceOnly",
        "GIVEN F1_CERT stale WHEN evaluated THEN TradingMode=ReduceOnly with no last-known-good bypass (AT-021)",
        "GIVEN contract_version format with 'v' prefix WHEN validated THEN reject (AT-012)"
      ],
      "steps": [
        "Define runtime_config_hash = sha256(canonical_json_bytes(runtime_config))",
        "Implement F1_CERT loading from artifacts/F1_CERT.json",
        "Implement binding validation: contract_version, build_id, runtime_config_hash",
        "Implement staleness check (no grace, no caching last-known-good)",
        "Add contract_version format validation (numeric-only, no 'v' prefix)",
        "Add test fixture: crates/soldier_core/tests/fixtures/F1_CERT.json",
        "Add all required tests (5 exact names)",
        "Add observability: f1_cert_age_s gauge, f1_cert_gate_block_opens_total counter"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_f1_gate"
      ],
      "evidence": [
        "crates/soldier_core/tests/test_f1_gate.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-012",
        "AT-020",
        "AT-021"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "f1_cert_age_s",
            "type": "gauge",
            "unit": "s",
            "labels": []
          },
          {
            "name": "f1_cert_gate_block_opens_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_f1_gate.rs"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "high",
      "needs_human_decision": false
    },
    {
      "id": "S8-002",
      "priority": 802,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.3 \u2014 EvidenceGuard (Patch B) enforcement + cooldown",
      "category": "evidence",
      "description": "Implement EvidenceGuard with strict >0.90 trip comparator, 60s rolling window, cooldown after recovery. Only enforced when enforced_profile != CSP. Includes PL-1 strict thresholds and AT-005 non-fill attribution exception.",
      "contract_refs": [
        "\u00a72.2.2 EvidenceGuard",
        "AT-005",
        "AT-105",
        "AT-107"
      ],
      "plan_refs": [
        "S8.3",
        "PL-1"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/src/analytics/evidence_chain_state.rs",
          "crates/soldier_core/src/policy/guard.rs",
          "crates/soldier_core/tests/test_evidence_guard.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN parquet_queue_depth_pct > 0.90 for \u22655s WHEN evaluated THEN EvidenceChainState != GREEN",
        "GIVEN parquet_queue_depth_pct == 0.90 WHEN evaluated THEN does NOT trip (strict comparator)",
        "GIVEN parquet_queue_depth_pct == 0.9001 for \u22655s WHEN evaluated THEN trips",
        "GIVEN EvidenceChainState != GREEN WHEN intent kind=OPEN THEN reject before WAL/dispatch",
        "GIVEN queue_depth_pct < 0.70 for \u2265120s AND cooldown elapsed WHEN evaluated THEN clear to GREEN",
        "GIVEN OPEN intent with zero fills WHEN checked THEN does NOT require attribution row (AT-005)",
        "GIVEN enforced_profile == CSP WHEN EvidenceGuard evaluated THEN NOT_ENFORCED"
      ],
      "steps": [
        "Implement EvidenceChainState computation over evidenceguard_window_s (60s)",
        "Check: truth_capsule_write_errors == 0, decision_snapshot_write_errors == 0, wal_write_errors == 0",
        "Implement strict trip comparator: parquet_queue_depth_pct > 0.90 (NOT >=)",
        "Implement clear condition: < 0.70 for \u2265120s AND evidenceguard_global_cooldown elapsed",
        "Implement fail-closed: missing queue depth => Evidence RED",
        "Implement hot-path enforcement in build_order_intent()",
        "Add profile isolation: EvidenceGuard NOT_ENFORCED when enforced_profile == CSP",
        "Emit exact metric names: parquet_queue_overflow_count, evidence_guard_blocked_opens_count",
        "Add all required tests including AT-005 non-fill attribution exception",
        "Add observability: evidence_chain_state gauge, evidence_guard_blocked_opens_total counter"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_evidence_guard"
      ],
      "evidence": [
        "crates/soldier_core/tests/test_evidence_guard.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-005",
        "AT-105",
        "AT-107"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "EvidenceGuard",
      "failure_mode": [
        "backpressure",
        "stall"
      ],
      "observability": {
        "metrics": [
          {
            "name": "evidence_chain_state",
            "type": "gauge",
            "unit": "count",
            "labels": []
          },
          {
            "name": "evidence_guard_blocked_opens_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_evidence_guard.rs"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false
    },
    {
      "id": "S8-003",
      "priority": 803,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.4 \u2014 Bunker Mode network jitter monitor (Patch C)",
      "category": "cortex",
      "description": "Implement bunker mode based on ws_event_lag_ms > 2000 OR http_p95_ms > 750 for 3 consecutive windows OR request_timeout_rate > 0.02. Exit only after 120s stable. Fail-closed if ws_event_lag_ms missing.",
      "contract_refs": [
        "\u00a72.3.2 Network Jitter Monitor",
        "AT-115",
        "AT-205",
        "AT-345"
      ],
      "plan_refs": [
        "S8.4"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/src/risk/network_jitter.rs",
          "crates/soldier_core/src/policy/guard.rs",
          "crates/soldier_core/tests/test_bunker_mode.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN ws_event_lag_ms > 2000 WHEN evaluated THEN bunker_mode_active=true, block OPENs",
        "GIVEN http_p95_ms > 750 for 3 consecutive windows WHEN evaluated THEN bunker_mode_active=true",
        "GIVEN request_timeout_rate > 0.02 WHEN evaluated THEN bunker_mode_active=true",
        "GIVEN ws_event_lag_ms missing/uncomputable WHEN evaluated THEN bunker_mode_active=true (fail-closed, AT-205)",
        "GIVEN bunker_mode_active AND metrics stable < thresholds for 120s WHEN evaluated THEN exit bunker mode"
      ],
      "steps": [
        "Implement network_jitter monitor with ws_event_lag_ms, http_p95_ms, request_timeout_rate inputs",
        "Implement trip thresholds: ws_event_lag_ms > 2000, http_p95_ms > 750 for 3 windows, timeout_rate > 0.02",
        "Implement 120s stable window for exit",
        "Implement fail-closed: ws_event_lag_ms missing => bunker_mode_active=true",
        "Add boundary tests for each threshold comparator",
        "Add all required tests (AT-115, AT-205, AT-345)",
        "Add observability: ws_event_lag_ms gauge, deribit_http_p95_ms gauge, bunker_mode_trip_total counter"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_bunker_mode"
      ],
      "evidence": [
        "crates/soldier_core/tests/test_bunker_mode.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-115",
        "AT-205",
        "AT-345"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "ws_event_lag_ms",
            "type": "gauge",
            "unit": "ms",
            "labels": []
          },
          {
            "name": "deribit_http_p95_ms",
            "type": "gauge",
            "unit": "ms",
            "labels": []
          },
          {
            "name": "bunker_mode_trip_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_bunker_mode.rs"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false
    },
    {
      "id": "S8-004",
      "priority": 804,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.5 \u2014 Cortex enforcement",
      "category": "cortex",
      "description": "Implement Reflexive Cortex: DVOL spike (\u226510% within 60s), spread_max_bps, depth_min triggers => ForceReduceOnly. WS gap blocks risk-increasing cancel/replace. Spread/depth extremes => ForceKill.",
      "contract_refs": [
        "\u00a72.3 Reflexive Cortex",
        "AT-045",
        "AT-119"
      ],
      "plan_refs": [
        "S8.5"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/src/reflex/cortex.rs",
          "crates/soldier_core/tests/test_cortex.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN dvol_jump_pct >= 0.10 within dvol_jump_window_s <= 60 WHEN evaluated THEN ForceReduceOnly",
        "GIVEN spread >= spread_max_bps OR depth < depth_min for kill_window WHEN evaluated THEN ForceKill (AT-045)",
        "GIVEN ws_gap_flag == true AND cancel/replace is risk-increasing WHEN evaluated THEN block at chokepoint (AT-119)",
        "GIVEN ws_gap_flag == true AND cancel/replace is risk-reducing WHEN evaluated THEN allow"
      ],
      "steps": [
        "Implement cortex.rs with DVOL, spread, depth monitors",
        "Implement DVOL jump detection: dvol_jump_pct >= 0.10 within 60s window",
        "Implement spread/depth thresholds: spread_max_bps, depth_min",
        "Define risk-increasing cancel/replace: increases |net_exposure| or removes reduce_only protection",
        "Implement ws_gap_flag enforcement: block risk-increasing cancel/replace",
        "Add required test aliases: test_cortex_spread_max_bps_forces_reduceonly, test_cortex_depth_min_forces_reduceonly",
        "Add all required tests (AT-045, AT-119)",
        "Add observability: cortex_override_total{kind} counter"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_cortex"
      ],
      "evidence": [
        "crates/soldier_core/tests/test_cortex.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-045",
        "AT-119"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "cortex_override_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "kind"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_cortex.rs"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false
    },
    {
      "id": "S8-005",
      "priority": 805,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.6 \u2014 Exchange maintenance monitor",
      "category": "cortex",
      "description": "Monitor /public/get_announcements for maintenance within 60m => RiskState::Maintenance, PolicyGuard forces ReduceOnly. Fail-closed if announcements unreachable/invalid for exchange_health_stale_s (default 180s).",
      "contract_refs": [
        "\u00a72.3.1 Exchange Health Monitor",
        "AT-204"
      ],
      "plan_refs": [
        "S8.6"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_core/src/risk/exchange_health.rs",
          "crates/soldier_core/tests/test_exchange_health.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN maintenance announced within 60m WHEN evaluated THEN RiskState=Maintenance, TradingMode=ReduceOnly",
        "GIVEN /public/get_announcements unreachable/invalid for >exchange_health_stale_s WHEN evaluated THEN cortex_override=ForceReduceOnly (AT-204)",
        "GIVEN /api/v1/status called WHEN RiskState=Maintenance THEN returns risk_state=Maintenance"
      ],
      "steps": [
        "Implement exchange_health monitor fetching /public/get_announcements",
        "Parse announcements for maintenance within next 60m",
        "Implement staleness check: unreachable/invalid for exchange_health_stale_s (default 180s)",
        "Implement fail-closed: stale announcements => cortex_override=ForceReduceOnly",
        "Set RiskState::Maintenance when maintenance imminent",
        "Add required tests (AT-204)",
        "Add observability for exchange health status"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_exchange_health"
      ],
      "evidence": [
        "crates/soldier_core/tests/test_exchange_health.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-204"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "exchange_health_status",
            "type": "gauge",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [
          "risk_state"
        ],
        "status_contract_ats": [
          "AT-204"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_exchange_health.rs"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false
    },
    {
      "id": "S8-006",
      "priority": 806,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.7 \u2014 Endpoint: POST /api/v1/emergency/reduce_only",
      "category": "endpoint",
      "description": "Owner endpoint to flip to ReduceOnly with cooldown. Cancels non-reduce-only opens, preserves closes/hedges. Smart Watchdog triggers same handler on ws_silence_ms > 5000.",
      "contract_refs": [
        "\u00a72.2 PolicyGuard",
        "\u00a73.2 Smart Watchdog"
      ],
      "plan_refs": [
        "S8.7"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_infra/tests/test_http_emergency.rs",
          "crates/soldier_infra/src/http/router.rs",
          "crates/soldier_core/src/policy/watchdog.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN POST /api/v1/emergency/reduce_only WHEN called THEN set emergency_reduceonly_until_ts_ms",
        "GIVEN emergency_reduceonly_active WHEN evaluated THEN cancel reduce_only==false orders, preserve closes/hedges",
        "GIVEN emergency_reduceonly_active AND exposure > limit WHEN evaluated THEN submit reduce-only hedge",
        "GIVEN ws_silence_ms > 5000 WHEN watchdog checked THEN invoke same emergency_reduceonly handler",
        "GIVEN cooldown expired AND reconcile confirms safe WHEN evaluated THEN clear emergency_reduceonly_active"
      ],
      "steps": [
        "Add POST /api/v1/emergency/reduce_only endpoint",
        "Implement emergency_reduceonly_until_ts_ms = now_ms + emergency_reduceonly_cooldown_s*1000",
        "PolicyGuard: treat emergency_reduceonly_active = (now_ms < emergency_reduceonly_until_ts_ms)",
        "Cancel reduce_only==false orders while active",
        "Preserve reduce_only closes/hedges",
        "Smart Watchdog: if ws_silence_ms > 5000, invoke emergency_reduceonly handler",
        "Add required endpoint-level test",
        "Add observability: http_emergency_reduce_only_calls_total counter"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test --workspace"
      ],
      "evidence": [
        "crates/soldier_infra/tests/test_http_S8-006.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "http_emergency_reduce_only_calls_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [],
        "status_contract_ats": []
      },
      "implementation_tests": [],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false
    },
    {
      "id": "S8-007",
      "priority": 807,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.8 \u2014 Owner endpoint: GET /api/v1/status (Patch D)",
      "category": "endpoint",
      "description": "Read-only status endpoint returning all required fields per \u00a77.0. Includes enforced_profile, trading_mode, risk_state, mode_reasons, open_permission state, policy/F1/disk/margin/cortex metrics. GOP extension keys when enforced_profile != CSP. Includes PL-5 f1_cert_expires_at semantics.",
      "contract_refs": [
        "\u00a77.0 Owner Control Plane Endpoints",
        "AT-003",
        "AT-022",
        "AT-023",
        "AT-024",
        "AT-025",
        "AT-026",
        "AT-027",
        "AT-028",
        "AT-029",
        "AT-405",
        "AT-407",
        "AT-419",
        "AT-907",
        "AT-927",
        "AT-967"
      ],
      "plan_refs": [
        "S8.8",
        "PL-5"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_infra/src/http/status.rs",
          "crates/soldier_infra/tests/test_http_status.rs",
          "crates/soldier_infra/src/http/router.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN GET /api/v1/status WHEN called THEN HTTP 200 JSON with status_schema_version=1 (AT-405)",
        "GIVEN GET /api/v1/status WHEN called THEN includes all required fields (AT-023)",
        "GIVEN trading_mode == Active WHEN status checked THEN mode_reasons == [] (AT-024)",
        "GIVEN mode_reasons returned WHEN checked THEN tier-pure and ordered (AT-025, AT-026)",
        "GIVEN open_permission_blocked_latch WHEN status checked THEN open_permission_reason_codes != [] (AT-027)",
        "GIVEN last_policy_update_ts WHEN status checked THEN equals python_policy_generated_ts_ms (AT-028)",
        "GIVEN snapshot_coverage_pct WHEN status checked THEN computed over replay_window_hours (AT-029)",
        "GIVEN enforced_profile == GOP WHEN status checked THEN includes GOP extension keys (AT-967)",
        "GIVEN enforced_profile == CSP WHEN status checked THEN GOP keys omitted or NOT_ENFORCED",
        "GIVEN F1_CERT present and parseable WHEN status checked THEN f1_cert_expires_at = generated_ts_ms + freshness_window_s*1000 (AT-003)"
      ],
      "steps": [
        "Create GET /api/v1/status endpoint",
        "Return required CSP fields: status_schema_version, supported_profiles, enforced_profile, trading_mode, risk_state, etc.",
        "Return required metrics: policy_age_sec, disk_used_pct, mm_util, wal_queue_depth, atomic_naked_events_24h, 429_count_5m, 10028_count_5m",
        "Return mode_reasons (tier-pure, ordered) and open_permission state",
        "When enforced_profile != CSP: include GOP extension keys (evidence_chain_state, snapshot_coverage_pct, replay_quality, etc.)",
        "Implement f1_cert_expires_at computation for any parseable F1_CERT (PL-5)",
        "Add 16 required endpoint-level tests",
        "Add observability: http_status_calls_total counter"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_http_status"
      ],
      "evidence": [
        "crates/soldier_infra/tests/test_http_status.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-003",
        "AT-022",
        "AT-023",
        "AT-024",
        "AT-025",
        "AT-026",
        "AT-027",
        "AT-028",
        "AT-029",
        "AT-405",
        "AT-407",
        "AT-419",
        "AT-907",
        "AT-927",
        "AT-967"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "StatusEndpoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "http_status_calls_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [
          "status_schema_version",
          "supported_profiles",
          "enforced_profile",
          "trading_mode",
          "risk_state",
          "bunker_mode_active",
          "connectivity_degraded",
          "policy_age_sec",
          "last_policy_update_ts",
          "f1_cert_state",
          "f1_cert_expires_at",
          "disk_used_pct",
          "mm_util",
          "mode_reasons",
          "open_permission_blocked_latch"
        ],
        "status_contract_ats": [
          "AT-003",
          "AT-023",
          "AT-024",
          "AT-025",
          "AT-026",
          "AT-027",
          "AT-028",
          "AT-029",
          "AT-405",
          "AT-967"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_http_status.rs"
      ],
      "dependencies": [],
      "est_size": "S",
      "risk": "low",
      "needs_human_decision": false
    },
    {
      "id": "S8-008",
      "priority": 808,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.9 \u2014 Owner endpoint: GET /api/v1/health (minimal, read-only)",
      "category": "endpoint",
      "description": "Minimal health endpoint returning ok=true, build_id, contract_version. Side-effect: update watchdog_last_heartbeat_ts_ms for PolicyGuard evaluation.",
      "contract_refs": [
        "\u00a77.0 Owner Control Plane Endpoints",
        "\u00a72.2.3 TradingMode Computation",
        "\u00a73.2 Smart Watchdog",
        "AT-022"
      ],
      "plan_refs": [
        "S8.9"
      ],
      "scope": {
        "touch": [],
        "create": [
          "crates/soldier_infra/src/http/health.rs",
          "crates/soldier_infra/tests/test_http_health.rs",
          "crates/soldier_infra/src/http/router.rs"
        ],
        "avoid": []
      },
      "acceptance": [
        "GIVEN GET /api/v1/health WHEN called THEN HTTP 200 JSON with ok=true, build_id, contract_version (AT-022)",
        "GIVEN GET /api/v1/health successful WHEN called THEN update watchdog_last_heartbeat_ts_ms = now_ms",
        "GIVEN non-GET request WHEN called THEN reject (AT-407)"
      ],
      "steps": [
        "Create GET /api/v1/health endpoint",
        "Return minimal payload: ok (bool, always true), build_id, contract_version",
        "Side-effect: update watchdog_last_heartbeat_ts_ms = now_ms in memory",
        "Add required endpoint-level test (AT-022)",
        "Add observability: http_health_calls_total counter"
      ],
      "passes": false,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_http_health"
      ],
      "evidence": [
        "crates/soldier_infra/tests/test_http_health.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-022"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "StatusEndpoint",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "http_health_calls_total",
            "type": "counter",
            "unit": "count",
            "labels": []
          }
        ],
        "status_fields": [
          "ok",
          "build_id",
          "contract_version"
        ],
        "status_contract_ats": [
          "AT-022"
        ]
      },
      "implementation_tests": [
        "crates/soldier_infra/tests/test_http_health.rs"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "low",
      "needs_human_decision": false
    },
    {
      "id": "S8-009",
      "priority": 809,
      "phase": 2,
      "slice": 8,
      "slice_ref": "Slice 8 \u2014 PolicyGuard + Cortex + Exchange Health + Bunker/Evidence/F1 + Owner Endpoints (Patch D)",
      "story_ref": "S8.10 \u2014 Basis monitor (Mark/Index/Last liquidation reality guard)",
      "category": "cortex",
      "description": "Basis monitor for liquidation reality check: if max(basis_mark_last_bps, basis_mark_index_bps) >= basis_kill_bps for kill_window => ForceKill. >= basis_reduceonly_bps for reduceonly_window => ForceReduceOnly. Missing/stale prices => fail-closed ForceReduceOnly.",
      "contract_refs": [
        "\u00a72.3.3 Mark/Index/Last Basis Monitor",
        "AT-951",
        "AT-952",
        "AT-954"
      ],
      "plan_refs": [
        "S8.10"
      ],
      "scope": {
        "touch": [
          "crates/soldier_core/src/risk/mod.rs",
          "crates/soldier_core/src/risk/basis_monitor.rs",
          "crates/soldier_core/tests/test_basis_monitor.rs"
        ],
        "create": [],
        "avoid": []
      },
      "acceptance": [
        "GIVEN max(basis_mark_last_bps, basis_mark_index_bps) >= basis_kill_bps for kill_window WHEN evaluated THEN ForceKill (AT-952)",
        "GIVEN max(...) >= basis_reduceonly_bps for reduceonly_window WHEN evaluated THEN ForceReduceOnly (AT-951)",
        "GIVEN required price missing/unparseable OR stale > basis_price_max_age_ms WHEN evaluated THEN ForceReduceOnly (AT-954)"
      ],
      "steps": [
        "Implement basis_monitor.rs with mark, index, last price inputs",
        "Compute basis_mark_last_bps and basis_mark_index_bps",
        "Implement kill threshold: max(...) >= basis_kill_bps for basis_kill_window_s",
        "Implement reduceonly threshold: max(...) >= basis_reduceonly_bps for basis_reduceonly_window_s",
        "Implement fail-closed: missing/stale price => ForceReduceOnly with cooldown",
        "Add all required tests (AT-951, AT-952, AT-954)",
        "Add observability: basis_trip_total counter"
      ],
      "passes": true,
      "verify": [
        "./plans/verify.sh",
        "cargo test -p soldier_core --lib --test test_basis_monitor"
      ],
      "evidence": [
        "crates/soldier_core/tests/test_basis_monitor.rs"
      ],
      "contract_must_evidence": [],
      "enforcing_contract_ats": [
        "AT-951",
        "AT-952",
        "AT-954"
      ],
      "reason_codes": {
        "type": "",
        "values": []
      },
      "enforcement_point": "PolicyGuard",
      "failure_mode": [],
      "observability": {
        "metrics": [
          {
            "name": "basis_trip_total",
            "type": "counter",
            "unit": "count",
            "labels": [
              "reason"
            ]
          }
        ],
        "status_fields": [],
        "status_contract_ats": [
          "AT-951",
          "AT-952",
          "AT-954"
        ]
      },
      "implementation_tests": [
        "crates/soldier_core/tests/test_basis_monitor.rs"
      ],
      "dependencies": [],
      "est_size": "XS",
      "risk": "med",
      "needs_human_decision": false
    }
  ]
}