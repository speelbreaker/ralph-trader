{
    "project": "StoicTrader",
    "source": {
        "implementation_plan_path": "IMPLEMENTATION_PLAN.md"
    },
    "rules": {
        "one_story_per_iteration": true,
        "one_commit_per_story": true,
        "no_prd_rewrite": true,
        "passes_only_flips_after_verify_green": true
    },
    "items": [
        {
            "id": "S2-001",
            "priority": 90,
            "phase": 1,
            "slice": 2,
            "slice_ref": "Slice 2 - Quantization + Labeling + Idempotency",
            "story_ref": "S2.1 Integer tick/step quantization",
            "category": "execution",
            "description": "Implement integer tick/step quantization with safe rounding and reject too-small orders after quantization.",
            "scope": {
                "touch": [
                    "crates/soldier_core/execution/quantize.rs",
                    "crates/soldier_core/tests/test_quantize.rs"
                ],
                "avoid": []
            },
            "acceptance": [
                "GIVEN raw_qty aligned to amount_step WHEN quantized THEN qty_q equals round_down(raw_qty, amount_step)",
                "GIVEN a BUY limit price WHEN quantized THEN limit_price_q rounds down to the nearest tick; GIVEN a SELL limit price WHEN quantized THEN limit_price_q rounds up to the nearest tick",
                "GIVEN qty_q < min_amount WHEN post-quantization validation runs THEN the intent is rejected and quantization_reject_too_small_total increments"
            ],
            "steps": [
                "Inspect crates/soldier_core/execution/quantize.rs for current rounding helpers and tick/step types.",
                "Implement qty_q round_down to amount_step and price rounding by side (BUY down, SELL up).",
                "Enforce min_amount after quantization and increment quantization_reject_too_small_total on reject.",
                "Instrument an in-memory metrics registry/mock for quantization_reject_too_small_total assertions in tests.",
                "Add tests test_quantization_rounding_buy_sell and test_rejects_too_small_after_quantization in crates/soldier_core/tests/test_quantize.rs.",
                "Run the targeted tests and plans/verify.sh."
            ],
            "verify": [
                "cargo test -p soldier_core --test test_quantize test_quantization_rounding_buy_sell",
                "cargo test -p soldier_core --test test_quantize test_rejects_too_small_after_quantization",
                "./plans/verify.sh"
            ],
            "evidence": [
                "Unit test asserts metric increment via in-memory metrics registry/mock for quantization_reject_too_small_total",
                "Test output from cargo test -p soldier_core --test test_quantize test_quantization_rounding_buy_sell",
                "Test output from cargo test -p soldier_core --test test_quantize test_rejects_too_small_after_quantization"
            ],
            "dependencies": [
                "S1-000"
            ],
            "est_size": "S",
            "risk": "med",
            "needs_human_decision": false,
            "passes": false
        },
        {
            "id": "S2-002",
            "priority": 80,
            "phase": 1,
            "slice": 2,
            "slice_ref": "Slice 2 - Quantization + Labeling + Idempotency",
            "story_ref": "S2.2 Intent hash from quantized fields",
            "category": "execution",
            "description": "Derive intent hashes solely from quantized fields to ensure deterministic idempotency across codepaths.",
            "scope": {
                "touch": [
                    "crates/soldier_core/idempotency/hash.rs",
                    "crates/soldier_core/tests/test_idempotency.rs"
                ],
                "avoid": []
            },
            "acceptance": [
                "GIVEN two codepaths producing the same quantized economic intent WHEN the hash is computed THEN the hashes are identical",
                "GIVEN a wall-clock timestamp input WHEN the hash is computed THEN it does not affect the resulting hash"
            ],
            "steps": [
                "Review crates/soldier_core/idempotency/hash.rs for hash inputs and canonical fields.",
                "Restrict hash inputs to quantized economic fields only and remove any time-based inputs.",
                "Add test test_intent_hash_deterministic_from_quantized in crates/soldier_core/tests/test_idempotency.rs.",
                "Run the targeted test and plans/verify.sh."
            ],
            "verify": [
                "cargo test -p soldier_core --test test_idempotency test_intent_hash_deterministic_from_quantized",
                "./plans/verify.sh"
            ],
            "evidence": [
                "Test output from cargo test -p soldier_core --test test_idempotency test_intent_hash_deterministic_from_quantized",
                "Code diff showing hash inputs restricted to quantized fields"
            ],
            "dependencies": [
                "S1-000",
                "S2-001"
            ],
            "est_size": "XS",
            "risk": "med",
            "needs_human_decision": false,
            "passes": false
        },
        {
            "id": "S2-003",
            "priority": 70,
            "phase": 1,
            "slice": 2,
            "slice_ref": "Slice 2 - Quantization + Labeling + Idempotency",
            "story_ref": "S2.3 Compact label schema encode/decode",
            "category": "execution",
            "description": "Implement compact label schema encode/decode with 64-character cap and safe truncation rules.",
            "scope": {
                "touch": [
                    "crates/soldier_core/execution/label.rs",
                    "crates/soldier_core/tests/test_label.rs"
                ],
                "avoid": []
            },
            "acceptance": [
                "GIVEN label fields sid8/gid12/li/ih16 WHEN encoded THEN the schema is s4:{sid8}:{gid12}:{li}:{ih16} and length does not exceed 64 characters",
                "GIVEN an overlength label WHEN encoding THEN only hashed fields are truncated and structural fields remain intact"
            ],
            "steps": [
                "Inspect crates/soldier_core/execution/label.rs for current label format and parsing.",
                "Implement compact encode/decode with the s4:{sid8}:{gid12}:{li}:{ih16} schema and length cap.",
                "Apply truncation rules to hashed fields only when length exceeds 64 characters.",
                "Add test test_label_compact_schema_length_limit in crates/soldier_core/tests/test_label.rs.",
                "Run the targeted test and plans/verify.sh."
            ],
            "verify": [
                "cargo test -p soldier_core --test test_label test_label_compact_schema_length_limit",
                "./plans/verify.sh"
            ],
            "evidence": [
                "Test output from cargo test -p soldier_core --test test_label test_label_compact_schema_length_limit",
                "Example label encode/decode assertion from the test"
            ],
            "dependencies": [
                "S1-000",
                "S2-002"
            ],
            "est_size": "S",
            "risk": "low",
            "needs_human_decision": false,
            "passes": false
        },
        {
            "id": "S2-004",
            "priority": 60,
            "phase": 1,
            "slice": 2,
            "slice_ref": "Slice 2 - Quantization + Labeling + Idempotency",
            "story_ref": "S2.4 Label match disambiguation and ambiguity handling",
            "category": "risk",
            "description": "Disambiguate label matches deterministically and fail-closed on ambiguity by degrading risk state.",
            "scope": {
                "touch": [
                    "crates/soldier_core/recovery/label_match.rs",
                    "crates/soldier_core/tests/test_label_match.rs",
                    "crates/soldier_core/risk/state.rs"
                ],
                "avoid": []
            },
            "acceptance": [
                "GIVEN multiple label candidates WHEN the disambiguation rules apply THEN a single deterministic match is selected",
                "GIVEN ambiguous label matches WHEN ambiguity is detected THEN RiskState::Degraded is set and opens are blocked",
                "GIVEN the opens-blocked latch is missing or cannot be confirmed WHEN attempting implementation THEN output exactly <promise>BLOCKED_MISSING_LATCH</promise> and do not mark passes=true"
            ],
            "steps": [
                "Locate and confirm the existing opens-blocked latch behavior and how RiskState::Degraded triggers it.",
                "If the latch cannot be confirmed, output <promise>BLOCKED_MISSING_LATCH</promise> and stop work on this story.",
                "Review crates/soldier_core/recovery/label_match.rs for current matching rules and tie-breakers.",
                "Implement deterministic disambiguation per contract tie-breakers.",
                "On ambiguity, set RiskState::Degraded, ensure the opens-blocked latch is triggered, and increment label_match_ambiguity_total.",
                "Instrument an in-memory metrics registry/mock for label_match_ambiguity_total assertions in tests.",
                "Add tests test_label_match_disambiguation and test_label_match_ambiguous_degrades in crates/soldier_core/tests/test_label_match.rs.",
                "Run the targeted tests and plans/verify.sh."
            ],
            "verify": [
                "cargo test -p soldier_core --test test_label_match test_label_match_disambiguation",
                "cargo test -p soldier_core --test test_label_match test_label_match_ambiguous_degrades",
                "./plans/verify.sh"
            ],
            "evidence": [
                "Unit test asserts metric increment via in-memory metrics registry/mock for label_match_ambiguity_total",
                "Test output from cargo test -p soldier_core --test test_label_match test_label_match_disambiguation",
                "Test output from cargo test -p soldier_core --test test_label_match test_label_match_ambiguous_degrades"
            ],
            "dependencies": [
                "S1-000",
                "S2-003"
            ],
            "est_size": "S",
            "risk": "med",
            "needs_human_decision": true,
            "passes": false
        }
    ]
}
